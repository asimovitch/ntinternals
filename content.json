{
      "intro": {
            "code": "\ntypedef struct _WELCOME {\n  PVOID                   ThisBlog;\n  ULONG                   Documents;\n  ULONG                   UndocumentedNTInternals;\n} WELCOME, *PWELCOME;\n",
            "description": "This website is just a basic revamp of the famous\n undocumented.ntinternals.net website by Tomasz Nowak\n(which does not exist anymore, sadly). Enjoy !"
      },
      "THREAD_BASIC_INFORMATION": {
            "code": "\ntypedef struct _THREAD_BASIC_INFORMATION {\n  NTSTATUS                ExitStatus;\n  PVOID                   TebBaseAddress;\n  CLIENT_ID               ClientId;\n  KAFFINITY               AffinityMask;\n  KPRIORITY               Priority;\n  KPRIORITY               BasePriority;\n} THREAD_BASIC_INFORMATION, *PTHREAD_BASIC_INFORMATION;\n",
            "description": "\nExitStatus Thread exit status. If\nthread is not terminated, it has STATUS_PENDING value. See\nalso Win32 API GetExitCodeThread.\nTebBaseAddress Address of TEB structure for specified thread. See also\nNtCurrentTeb.\nClientId Unique process id and thread\nid.\nAffinityMask Thread affinity mask.\nThere are no Win32 call GetThreadAffinityMask, but there's\nfunction SetThreadAffinityMask that's use\nAffinityMask value. See also\nThreadAffinityMask information class.\nPriority I'm not sure...\nBasePriority Thread base priority. Used\nby Kernel32.dll in function\nGetThreadPriority. See also \nThreadBasePriority information class.\nStructure is used with \nThreadBasicInformation information class in \nNtQueryInformationThread call.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtQueryInformationThread\nTHREAD_INFORMATION_CLASS\n"
      },
      "SYSTEM_MODULE_INFORMATION": {
            "code": "\ntypedef struct _SYSTEM_MODULE_INFORMATION {\n  ULONG                ModulesCount;\n  SYSTEM_MODULE        Modules[0];\n} SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;\n",
            "description": "\nSee SYSTEM_MODULE\nfor details. See \nNtQuerySystemInformation with\nSystemModuleInformation class for global module\nenumeration. See \nLdrQueryProcessModuleInformation for process module\nenumeration.\n"
      },
      "RTL_DRIVE_LETTER_CURDIR": {
            "code": "\ntypedef struct _RTL_DRIVE_LETTER_CURDIR {\n  USHORT                  Flags;\n  USHORT                  Length;\n  ULONG                   TimeStamp;\n  UNICODE_STRING          DosPath;\n} RTL_DRIVE_LETTER_CURDIR, *PRTL_DRIVE_LETTER_CURDIR;\n",
            "description": "\n-???\n"
      },
      "LDR_MODULE": {
            "code": "\ntypedef struct _LDR_MODULE {\n  LIST_ENTRY              InLoadOrderModuleList;\n  LIST_ENTRY              InMemoryOrderModuleList;\n  LIST_ENTRY              InInitializationOrderModuleList;\n  PVOID                   BaseAddress;\n  PVOID                   EntryPoint;\n  ULONG                   SizeOfImage;\n  UNICODE_STRING          FullDllName;\n  UNICODE_STRING          BaseDllName;\n  ULONG                   Flags;\n  SHORT                   LoadCount;\n  SHORT                   TlsIndex;\n  LIST_ENTRY              HashTableEntry;\n  ULONG                   TimeDateStamp;\n} LDR_MODULE, *PLDR_MODULE;\n",
            "description": "\n"
      },
      "INITIAL_TEB": {
            "code": "\ntypedef struct _INITIAL_TEB {\n  PVOID                StackBase;\n  PVOID                StackLimit;\n  PVOID                StackCommit;\n  PVOID                StackCommitMax;\n  PVOID                StackReserved;\n} INITIAL_TEB, *PINITIAL_TEB;\n",
            "description": "\nStackBase\n"
      },
      "SYSTEM_MODULE": {
            "code": "\ntypedef struct _SYSTEM_MODULE {\n  ULONG                Reserved1;\n  ULONG                Reserved2;\n  PVOID                ImageBaseAddress;\n  ULONG                ImageSize;\n  ULONG                Flags;\n  WORD                 Id;\n  WORD                 Rank;\n  WORD                 w018;\n  WORD                 NameOffset;\n  BYTE                 Name[MAXIMUM_FILENAME_LENGTH];\n} SYSTEM_MODULE, *PSYSTEM_MODULE;\n",
            "description": "\nReserved1\nReserved (always 0xBAADF00D).\n"
      },
      "OBJECT_NAME_INFORMATION": {
            "code": "\ntypedef struct _OBJECT_NAME_INFORMATION {\n  UNICODE_STRING          Name;\n  WCHAR                   NameBuffer[0];\n} OBJECT_NAME_INFORMATION, *POBJECT_NAME_INFORMATION;\n",
            "description": "\nStructure OBJECT_NAME_INFORMATION is used as a result\nof call \nNtQueryObject with ObjectNameInformation information\nclass.\nName Name of object or NULL if\nobject don't have associated name.\nNameBuffer[0] Buffer with UNICODE name\nof object.\nSupported on system versions:\nNT 4.0,Win 2000,Win XP/2003\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtQueryObject\nOBJECT_INFORMATION_CLASS\n"
      },
      "PEB_LDR_DATA": {
            "code": "\ntypedef struct _PEB_LDR_DATA {\n  ULONG                   Length;\n  BOOLEAN                 Initialized;\n  PVOID                   SsHandle;\n  LIST_ENTRY              InLoadOrderModuleList;\n  LIST_ENTRY              InMemoryOrderModuleList;\n  LIST_ENTRY              InInitializationOrderModuleList;\n} PEB_LDR_DATA, *PPEB_LDR_DATA;\n",
            "description": "\n"
      },
      "MUTANT_BASIC_INFORMATION": {
            "code": "\ntypedef struct _MUTANT_BASIC_INFORMATION {\n  LONG                    CurrentCount;\n  BOOLEAN                 OwnedByCaller;\n  BOOLEAN                 AbandonedState;\n} MUTANT_BASIC_INFORMATION, *PMUTANT_BASIC_INFORMATION;\n",
            "description": "\nUse MUTANT_BASIC_INFORMATION as a buffer in NtQueryMutant call.\n"
      },
      "SECTION_BASIC_INFORMATION": {
            "code": "\ntypedef struct _SECTION_BASIC_INFORMATION {\n  ULONG                   Unknown;\n  ULONG                   SectionAttributes;\n  LARGE_INTEGER           SectionSize;\n} SECTION_BASIC_INFORMATION, *PSECTION_BASIC_INFORMATION;\n",
            "description": "\nStructure SECTION_BASIC_INFORMATION is returned as a\nresult of call \nNtQuerySection with \nSectionBasicInformation information class.\nUnknown (?), always set\nto zero.\nSectionAttributes Can be one or\ncombination of:\nSEC_RESERVE\nSEC_IMAGE\nSEC_FILE\nSectionSize Size of section, in bytes.\nThis value equals to section's size declared in a call to \nNtCreateSection or \nNtExtendSection.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCreateSection\nNtExtendSection\nNtQuerySection\nSECTION_IMAGE_INFORMATION\nSECTION_INFORMATION_CLASS\n"
      },
      "RTL_USER_PROCESS_PARAMETERS": {
            "code": "\ntypedef struct _RTL_USER_PROCESS_PARAMETERS {\n  ULONG                   MaximumLength;\n  ULONG                   Length;\n  ULONG                   Flags;\n  ULONG                   DebugFlags;\n  PVOID                   ConsoleHandle;\n  ULONG                   ConsoleFlags;\n  HANDLE                  StdInputHandle;\n  HANDLE                  StdOutputHandle;\n  HANDLE                  StdErrorHandle;\n  UNICODE_STRING          CurrentDirectoryPath;\n  HANDLE                  CurrentDirectoryHandle;\n  UNICODE_STRING          DllPath;\n  UNICODE_STRING          ImagePathName;\n  UNICODE_STRING          CommandLine;\n  PVOID                   Environment;\n  ULONG                   StartingPositionLeft;\n  ULONG                   StartingPositionTop;\n  ULONG                   Width;\n  ULONG                   Height;\n  ULONG                   CharWidth;\n  ULONG                   CharHeight;\n  ULONG                   ConsoleTextAttributes;\n  ULONG                   WindowFlags;\n  ULONG                   ShowWindowFlags;\n  UNICODE_STRING          WindowTitle;\n  UNICODE_STRING          DesktopName;\n  UNICODE_STRING          ShellInfo;\n  UNICODE_STRING          RuntimeData;\n  RTL_DRIVE_LETTER_CURDIR DLCurrentDirectory[0x20];\n} RTL_USER_PROCESS_PARAMETERS, *PRTL_USER_PROCESS_PARAMETERS;\n",
            "description": "\n"
      },
      "THREAD_TIMES_INFORMATION": {
            "code": "\ntypedef struct _THREAD_TIMES_INFORMATION {\n  LARGE_INTEGER           CreationTime;\n  LARGE_INTEGER           ExitTime;\n  LARGE_INTEGER           KernelTime;\n  LARGE_INTEGER           UserTime;\n} THREAD_TIMES_INFORMATION, *PTHREAD_TIMES_INFORMATION;\n",
            "description": "\n"
      },
      "RTL_USER_PROCESS_INFORMATION": {
            "code": "\ntypedef struct _RTL_USER_PROCESS_INFORMATION {\n  ULONG                   Size;\n  HANDLE                  ProcessHandle;\n  HANDLE                  ThreadHandle;\n  CLIENT_ID               ClientId;\n  SECTION_IMAGE_INFORMATION ImageInformation;\n} RTL_USER_PROCESS_INFORMATION, *PRTL_USER_PROCESS_INFORMATION;\n",
            "description": "\n"
      },
      "OBJDIR_INFORMATION": {
            "code": "\ntypedef struct _OBJDIR_INFORMATION {\n  UNICODE_STRING          ObjectName;\n  UNICODE_STRING          ObjectTypeName;\n  BYTE                    Data[1];\n} OBJDIR_INFORMATION, *POBJDIR_INFORMATION;\n",
            "description": "\nStructure is used with NtQueryDirectoryObject function. Contains information of named object placed in object directory space.\n"
      },
      "RTL_HEAP_DEFINITION": {
            "code": "\ntypedef struct _RTL_HEAP_DEFINITION {\n  ULONG                   Length;\n  ULONG                   Unknown1;\n  ULONG                   Unknown2;\n  ULONG                   Unknown3;\n  ULONG                   Unknown4;\n  ULONG                   Unknown5;\n  ULONG                   Unknown6;\n  ULONG                   Unknown7;\n  ULONG                   Unknown8;\n  ULONG                   Unknown9;\n  ULONG                   Unknown10;\n  ULONG                   Unknown11;\n  ULONG                   Unknown12;\n} RTL_HEAP_DEFINITION, *PRTL_HEAP_DEFINITION;\n",
            "description": "\n"
      },
      "SYSTEM_REGISTRY_QUOTA_INFORMATION": {
            "code": "\ntypedef struct _SYSTEM_REGISTRY_QUOTA_INFORMATION {\n  ULONG                   RegistryQuotaAllowed;\n  ULONG                   RegistryQuotaUsed;\n  ULONG                   PagedPoolSize;\n} SYSTEM_REGISTRY_QUOTA_INFORMATION, *PSYSTEM_REGISTRY_QUOTA_INFORMATION;\n",
            "description": "\n"
      },
      "SECTION_IMAGE_INFORMATION": {
            "code": "\ntypedef struct _SECTION_IMAGE_INFORMATION {\n  PVOID                   EntryPoint;\n  ULONG                   StackZeroBits;\n  ULONG                   StackReserved;\n  ULONG                   StackCommit;\n  ULONG                   ImageSubsystem;\n  WORD                    SubSystemVersionLow;\n  WORD                    SubSystemVersionHigh;\n  ULONG                   Unknown1;\n  ULONG                   ImageCharacteristics;\n  ULONG                   ImageMachineType;\n  ULONG                   Unknown2[3];\n} SECTION_IMAGE_INFORMATION, *PSECTION_IMAGE_INFORMATION;\n",
            "description": "\nStructure SECTION_IMAGE_INFORMATION is returned as a\nresult of call \nNtQuerySection with \nSectionImageInformation information class. System automatically\ncheck type and contents of File Object passed as a parameter to\nfunction \nNtCreateSection, and sets SEC_IMAGE bit on Section\nAttributes.\nThis structure is very useful in process creation, becouse caller\ncan check most interesting of PE Header fields just before\ncall to \nNtCreateProcess and without mapping section to target\nprocess'es memory.\nEntryPoint Image's entry point.\nStackZeroBits Number of bits from left\nside of stack address must be set to zero. It means maximum stack's\naddress in process memory.\nStackReserved Total size of stack, in\nbytes.\nStackCommit Initially commited stack's\nblock size.\nImageSubsystem One of\nIMAGE_SUBSYSTEM_* descripted in Microsoft SDK and\navaiable in &lt;winnt.h&gt; header file.\nSubSystemVersionLow Minor version\nnumber of subsystem.\nSubSystemVersionHigh Major version\nnumber of subsystem.\nUnknown1 (?)\nImageCharacteristics DLL\nCharacteristics.\nImageMachineType One of\nIMAGE_FILE_MACHINE_*.\nUnknown2[3] (?)\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCreateProcess\nNtCreateSection\nNtMapViewOfSection\nNtOpenSection\nNtQuerySection\nSECTION_BASIC_INFORMATION\nSECTION_INFORMATION_CLASS\n"
      },
      "NtQueryInformationAtom": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtQueryInformationAtom(\n  IN RTL_ATOM             Atom,\n  IN ATOM_INFORMATION_CLASS AtomInformationClass,\n  OUT PVOID               AtomInformation,\n  IN ULONG                AtomInformationLength,\n  OUT PULONG              ReturnLength OPTIONAL );\n",
            "description": "\nNtQueryInformationAtom is used to get single Atom\nproperties or to read Global Atom Table.\nAtom Atom to query. If AtomInformationClass parameter is AtomTableInformation, Atom parameter is not used.\nAtomInformationClass See ATOM_INFORMATION_CLASS\nenumeration type for details.\nAtomInformation Result of call -\npointer to user's allocated buffer for data.\nAtomInformationLength Size of\nAtomInformation buffer, in\nbytes.\nReturnLength Pointer to ULONG\nvalue contains required AtomInformation buffer size.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nATOM_INFORMATION_CLASS\nATOM_TABLE_INFORMATION\nNtAddAtom\nNtFindAtom\n"
      },
      "ATOM_INFORMATION_CLASS": {
            "code": "\ntypedef enum _ATOM_INFORMATION_CLASS {\n    AtomBasicInformation,\n    AtomTableInformation\n} ATOM_INFORMATION_CLASS, *PATOM_INFORMATION_CLASS;\n",
            "description": "\nEnumeration type ATOM_INFORMATION_CLASS is used in a\ncall to function NtQueryInformationAtom.\nAtomBasicInformation Result of call\ncontains ATOM_BASIC_INFORMATION\nstructure.\nAtomTableInformation Result of call\ncontains ATOM_TABLE_INFORMATION\nstructure.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nATOM_BASIC_INFORMATION\nATOM_TABLE_INFORMATION\nNtQueryInformationAtom\n"
      },
      "NtAddAtom": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtAddAtom(\n  IN PWCHAR               AtomName,\n  OUT PRTL_ATOM           Atom );\n",
            "description": "\nFunction NtAddAtom creates new Atom in Global Atom\nTable. If Atom with the same name already exist, internal Atom\ncounter is incremented.\nAtomName UNICODE Atom name.\nAtom Result of call - pointer to\nRTL_ATOM.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nATOM_BASIC_INFORMATION\nNtDeleteAtom\nNtFindAtom\nNtQueryInformationAtom\n"
      },
      "NtDeleteAtom": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtDeleteAtom(\n  IN RTL_ATOM             Atom );\n",
            "description": "\nFunction NtDeleteAtom remove Atom from Global Atom\nTable. If Atom's reference counter is greater then 1,\nfunction decrements this counter, but Atom stayed in Global Atom\nTable.\nAtom Atom identifier.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nATOM_BASIC_INFORMATION\nNtAddAtom\nNtFindAtom\nNtQueryInformationAtom\n"
      },
      "NtFindAtom": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtFindAtom(\n  IN PWCHAR               AtomName,\n  OUT PRTL_ATOM           Atom OPTIONAL );\n",
            "description": "\nFunction NtFindAtom retrieve existing Atom's\nidentifier without incrementing Atom's internal counter.\nAtomName Atom's name, in UNICODE\nformat.\nAtom Result of call - Pointer to Atom's\nidentifier.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nATOM_BASIC_INFORMATION\nATOM_TABLE_INFORMATION\nNtAddAtom\nNtDeleteAtom\nNtQueryInformationAtom\n"
      },
      "ATOM_TABLE_INFORMATION": {
            "code": "\ntypedef struct _ATOM_TABLE_INFORMATION {\n  ULONG                   NumberOfAtoms;\n  RTL_ATOM                Atoms[1];\n} ATOM_TABLE_INFORMATION, *PATOM_TABLE_INFORMATION;\n",
            "description": "\nATOM_TABLE_INFORMATION descriptes Global Atom Table.\nIs returned as a result of call NtQueryInformationAtom with\nAtomTableInformation\ninformation class.\nNumberOfAtoms Number of members in\nAtoms array.\nAtoms[1] Array of Global Atoms.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nATOM_BASIC_INFORMATION\nATOM_INFORMATION_CLASS\nNtQueryInformationAtom\n"
      },
      "ATOM_BASIC_INFORMATION": {
            "code": "\ntypedef struct _ATOM_BASIC_INFORMATION {\n  USHORT                  UsageCount;\n  USHORT                  Flags;\n  USHORT                  NameLength;\n  WCHAR                   Name[1];\n} ATOM_BASIC_INFORMATION, *PATOM_BASIC_INFORMATION;\n",
            "description": "\nATOM_BASIC_INFORMATION structure is returned as a\nresult of call NtQueryInformationAtom\nwith AtomBasicInformation\ninformation class.\nUsageCount Internal Atom counter state.\nThis value increments at every NtAddAtom\ncall for current Atom, and it's decremented on every NtDeleteAtom\nfunction call.\nFlags (?), Only lowest\nbit is used.\nNameLength Size of Name array, in bytes.\nName[1] Atom name.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nATOM_INFORMATION_CLASS\nNtAddAtom\nNtDeleteAtom\nNtQueryInformationAtom\n"
      },
      "SHUTDOWN_ACTION": {
            "code": "\ntypedef enum _SHUTDOWN_ACTION {\n    ShutdownNoReboot,\n    ShutdownReboot,\n    ShutdownPowerOff\n} SHUTDOWN_ACTION, *PSHUTDOWN_ACTION;\n",
            "description": "\nEnumeration type SHUTDOWN_ACTION is used in a call to\nNtShutdownSystem\nfunction.\nShutdownNoReboot Normal shutdown, after\nsystem closes, processor jump into infinite loop.\nShutdownReboot BIOS Reset\nfunction is called, after system closes.\nShutdownPowerOff BIOS Shutdown\nfunction is called after system closes. If hardware does not\nsupport this functionality, ShutdownReboot is automatically called.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtShutdownSystem\n"
      },
      "NtShutdownSystem": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtShutdownSystem(\n  IN SHUTDOWN_ACTION      Action );\n",
            "description": "\nFunction NtShutdownSystem closes system. Caller\nshould manually inform running processes about pending shutdown\naction.\nAction Type of shudown defined in\nSHUTDOWN_ACTION\nenumeration type.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\nPrivilege: SE_SHUTDOWN_PRIVILEGE\n\nSee also:\nSHUTDOWN_ACTION\n"
      },
      "NtFlushWriteBuffer": {
            "code": "\nNTSYSAPI\nNTSTATUS\nNTAPI\nNtFlushWriteBuffer(\n );\n",
            "description": "\nFunction NtFlushWriteBuffer does nothing...\nIt test IRQ Level, and call HAL export named\nKeFlushWriteBuffer.\nKeFlushWriteBuffer as first asm code has\nret, so it returns immediatelly.\nNext NtFlushWriteBuffer clear eax (set\nresult of call to STATUS_SUCCESS) and returns to\nUser-Mode.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\n"
      },
      "NtSetDefaultLocale": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtSetDefaultLocale(\n  IN BOOLEAN              UserProfile,\n  IN LCID                 DefaultLocaleId );\n",
            "description": "\nFunction NtSetDefaultLocale sets default Kernel or\nUser Mode locale. See Microsoft SDK for detailed description\nabout locale codes.\nUserProfile If set, function sets\nUserMode locale. If not, KernelMode locale is\nmodified.\nDefaultLocaleId Locale to set.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtQueryDefaultLocale\n"
      },
      "NtQueryDefaultLocale": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtQueryDefaultLocale(\n  IN BOOLEAN              UserProfile,\n  OUT PLCID               DefaultLocaleId );\n",
            "description": "\nFunction NtQueryDefaultLocale returns current Locale\nIdentifier. Locale Identifier if defined as DWORD value, and\ncontains locale code, sublocale etc. For more information about\nLCID see Microsoft SDK.\nUserProfile If set, function returns\nUserMode default locale. If not, result is system\nlocale.\nDefaultLocaleId Pointer to LCID\nvalue receiving current locale.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtSetDefaultLocale\n"
      },
      "NtQueueApcThread": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtQueueApcThread(\n  IN HANDLE               ThreadHandle,\n  IN PIO_APC_ROUTINE      ApcRoutine,\n  IN PVOID                ApcRoutineContext OPTIONAL,\n  IN PIO_STATUS_BLOCK     ApcStatusBlock OPTIONAL,\n  IN ULONG                ApcReserved OPTIONAL );\n",
            "description": "\nThreadHandle\nOpen handle to any Thread Object, including caller's thread.\n"
      },
      "NtCallbackReturn": {
            "code": "\nNTSYSAPI\nNTSTATUS\nNTAPI\nNtCallbackReturn(\n  IN PVOID                Result OPTIONAL,\n  IN ULONG                ResultLength,\n  IN NTSTATUS             Status );\n",
            "description": "\nFunction NtCallbackReturn finish execution of\nUser-Mode callback.\nResult Pointer to user's allocated\nbuffer with custom data.\nResultLength Length of Result buffer, in bytes.\nStatus Callback execution status\ncode.\n\nDocumented by:\nReactos\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nKiUserCallbackDispatcher\n"
      },
      "KiUserApcDispatcher": {
            "code": "\nNTSYSAPI \nVOID\nNTAPI\nKiUserApcDispatcher(\n  IN PVOID                Unused1,\n  IN PVOID                Unused2,\n  IN PVOID                Unused3,\n  IN PVOID                ContextStart,\n  IN PVOID                ContextBody );\n",
            "description": "\nUnused1 Unused parameters. Sometimes\none of them have ntdll.dll module address.\nUnused2 See Unused1.\nUnused3 See Unused1.\nContextStart Begining of ContextStart CONTEXT structure\nis stored.\nContextBody Four bytes from\nCONTEXT structure at offset 0x04.\nKiUserApcDispatcher isn't standard\nntdll function. It's used by kernel to process APC\nqueue for calling thread. Five paraters I defined only for\ncompatibility with ntdll.lib export\n(_KiUserApcDispatcher@20). Function first execute code\nplaced after call, and next calls NtContinue with\nCONTEXT specified at 4 parameter position\n(Warning: Not pointer to\nCONTEXT, but CONTEXT body must be\nstored on stack).\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtAlertThread\nNtContinue\nNtQueueApcThread\nNtTestAlert\n"
      },
      "NtAlertThread": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtAlertThread(\n  IN HANDLE               ThreadHandle );\n",
            "description": "\n"
      },
      "NtTestAlert": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtTestAlert(\n );\n",
            "description": "\nYou can use NtTestAlert to empty APC queue for current thread. If APC queue was empty before call, NtTestAlert has no efect.\nNtTestAlert is typical ntcall kernel routine, accessable via int 2Eh. It check thread APC queue, and call KiUserApcDispatcher. \n"
      },
      "NtPrivilegedServiceAuditAlarm": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtPrivilegedServiceAuditAlarm(\n  IN PUNICODE_STRING      SubsystemName OPTIONAL,\n  IN PUNICODE_STRING      ServiceName OPTIONAL,\n  IN HANDLE               ClientToken,\n  IN PPRIVILEGE_SET       ClientPrivileges,\n  IN BOOLEAN              AccessGranted );\n",
            "description": "\nFunction NtPrivilegedServiceAuditAlarm doesn't work\non NT40-SP6. For more information see description of\nPrivilegedServiceAuditAlarm in Microsoft SDK.\nSubsystemName - ???\nServiceName - ???\nClientToken HANDLE to Token\nObject opened with TOKEN_QUERY access.\nClientPrivileges Pointer to PRIVILEGE_SET structure contains valid\ndata.\nAccessGranted - ???\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\nPrivilege: SE_AUDIT_PRIVILEGE\n\nSee also:\nNtOpenObjectAuditAlarm\nNtPrivilegeObjectAuditAlarm\nPRIVILEGE_SET\n"
      },
      "NtPrivilegeObjectAuditAlarm": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtPrivilegeObjectAuditAlarm(\n  IN PUNICODE_STRING      SubsystemName OPTIONAL,\n  IN HANDLE               ObjectHandle OPTIONAL,\n  IN HANDLE               ClientToken,\n  IN ULONG                DesiredAccess,\n  IN PPRIVILEGE_SET       ClientPrivileges,\n  IN BOOLEAN              AccessGranted );\n",
            "description": "\nFunction NtPrivilegeObjectAuditAlarm doesn't work, as\nthe most of other auditing functions...\nSubsystemName - ???\nObjectHandle This can be any\nvalue.\nClientToken HANDLE to Token\nObject opened with TOKEN_QUERY access.\nDesiredAccess - ???\nClientPrivileges Pointer to PRIVILEGE_SET structure filled with valid\ndata.\nAccessGranted - ???\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\nPrivilege: SE_AUDIT_PRIVILEGE\n\nSee also:\nNtAccessCheckAndAuditAlarm\nNtOpenObjectAuditAlarm\nNtPrivilegedServiceAuditAlarm\nPRIVILEGE_SET\n"
      },
      "NtOpenObjectAuditAlarm": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtOpenObjectAuditAlarm(\n  IN PUNICODE_STRING      SubsystemName OPTIONAL,\n  IN PHANDLE              ObjectHandle OPTIONAL,\n  IN PUNICODE_STRING      ObjectTypeName OPTIONAL,\n  IN PUNICODE_STRING      ObjectName OPTIONAL,\n  IN PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL,\n  IN HANDLE               ClientToken,\n  IN ACCESS_MASK          DesiredAccess,\n  IN ACCESS_MASK          GrantedAccess,\n  IN PPRIVILEGE_SET       Privileges OPTIONAL,\n  IN BOOLEAN              ObjectCreation,\n  IN BOOLEAN              AccessGranted,\n  OUT PBOOLEAN            GenerateOnClose OPTIONAL );\n",
            "description": "\nFunction NtOpenObjectAuditAlarm does not work on\nNT40-SP6. For additional information see description of\nObjectOpenAuditAlarm function in Microsoft SDK.\nSubsystemName - ???\nObjectHandle Can be any valid\nHANDLE to object, or NULL.\nObjectTypeName - ???\nObjectName - ???\nSecurityDescriptor Pointer to SECURITY_DESCRIPTOR structure, or\nNULL.\nClientToken HANDLE to Token\nObject previously opened with TOKEN_QUERY access.\nDesiredAccess - ???\nGrantedAccess - ???\nPrivileges Optionally pointer to\nPRIVILEGE_SET structure filled by\nuser with valid privileges.\nObjectCreation - ???\nAccessGranted = ???\nGenerateOnClose Optionally pointer to\nBOOLEAN value.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\nPrivilege: SE_AUDIT_PRIVILEGE\n\nSee also:\nNtAccessCheckAndAuditAlarm\nNtCloseObjectAuditAlarm\nNtDeleteObjectAuditAlarm\nPRIVILEGE_SET\nSECURITY_DESCRIPTOR\n"
      },
      "NtSetSecurityObject": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtSetSecurityObject(\n  IN HANDLE               ObjectHandle,\n  IN SECURITY_INFORMATION SecurityInformationClass,\n  IN PSECURITY_DESCRIPTOR DescriptorBuffer );\n",
            "description": "\nFunction NtSetSecurityDescriptor writes object's\nSecurity Descriptor.\nObjectHandle HANDLE to object of\nany type. Must be opened with WRITE_DAC or\nWRITE_OWNER access dependly to SecurityInformationClass parameter.\nSecurityInformationClass See \nNtQuerySecurityObject for possible values.\nDescriptorBuffer Pointer to user's\nallocated SECURITY_DESCRIPTOR to set.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtQuerySecurityObject\nSECURITY_DESCRIPTOR\n"
      },
      "NtDeleteObjectAuditAlarm": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtDeleteObjectAuditAlarm(\n  IN PUNICODE_STRING      SubsystemName,\n  IN HANDLE               ObjectHandle OPTIONAL,\n  IN BOOLEAN              GenerateOnClose );\n",
            "description": "\nFunction NtDeleteObjectAuditAlarm generates\nSecurity Audit Alarm, stored in Event Log. See also\ndescription of \nNtCloseObjectAuditAlarm.\nSubsystemName This string is passed as\na parameter to event message.\nObjectHandle HANDLE to any\nobject.\nGenerateOnClose If set, event is\ngenerated.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\nPrivilege: SE_AUDIT_PRIVILEGE\n\nSee also:\nNtCloseObjectAuditAlarm\nNtOpenObjectAuditAlarm\n"
      },
      "NtCloseObjectAuditAlarm": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtCloseObjectAuditAlarm(\n  IN PUNICODE_STRING      SubsystemName,\n  IN HANDLE               ObjectHandle OPTIONAL,\n  IN BOOLEAN              GenerateOnClose );\n",
            "description": "\nFunction NtCloseObjectAuditAlarm sends alarm to Event\nLog, section Security. Alarm informs about close user's created\nobject.\nSubsystemName This string is sent to\nEvent Log as the first parameter.\nObjectHandle HANDLE to object,\nor NULL value.\nGenerateOnClose If set, event is\ngenerated.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\nPrivilege: SE_AUDIT_PRIVILEGE\n\nSee also:\nNtAccessCheckAndAuditAlarm\nNtDeleteObjectAuditAlarm\nNtOpenObjectAuditAlarm\n"
      },
      "NtAccessCheckAndAuditAlarm": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtAccessCheckAndAuditAlarm(\n  IN PUNICODE_STRING      SubsystemName OPTIONAL,\n  IN HANDLE               ObjectHandle OPTIONAL,\n  IN PUNICODE_STRING      ObjectTypeName OPTIONAL,\n  IN PUNICODE_STRING      ObjectName OPTIONAL,\n  IN PSECURITY_DESCRIPTOR SecurityDescriptor,\n  IN ACCESS_MASK          DesiredAccess,\n  IN PGENERIC_MAPPING     GenericMapping,\n  IN BOOLEAN              ObjectCreation,\n  OUT PULONG              GrantedAccess,\n  OUT PULONG              AccessStatus,\n  OUT PBOOLEAN            GenerateOnClose );\n",
            "description": "\nFunction NtAccessCheckAndAuditAlarm doesn't work\nproperly on NT40-SP6. For more information about alarms see\ndescription of similar function AccessCheckAndAuditAlarm in\nMicrosoft SDK.\nSubsystemName - ???\nObjectHandle Can be any valid\nHANDLE to object, or NULL.\nObjectTypeName - ???\nObjectName - ???\nSecurityDescriptor Pointer to\n\"Absolute\" SECURITY_DESCRIPTOR structure.\nDesiredAccess - ???\nGenericMapping Pointer to\nGENERIC_MAPPING structure valid for object specified above\nas ObjectHandle parameter.\nObjectCreation - ???\nGrantedAccess Pointer to\nACCESS_MASK value (?).\nAccessStatus Pointer to NTSTATUS\nvalue (?).\nGenerateOnClose Pointer to\nBOOLEAN value (?).\nFunction can be called only from impersonated thread. (See \nNtImpersonateThread for more information).\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\nPrivilege: SE_AUDIT_PRIVILEGE\n\nSee also:\nNtAccessCheck\nNtCloseObjectAuditAlarm\nNtDeleteObjectAuditAlarm\nNtImpersonateThread\nNtOpenObjectAuditAlarm\nSECURITY_DESCRIPTOR\n"
      },
      "NtAccessCheck": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtAccessCheck(\n  IN PSECURITY_DESCRIPTOR SecurityDescriptor,\n  IN HANDLE               ClientToken,\n  IN ACCESS_MASK          DesiredAccess,\n  IN PGENERIC_MAPPING     GenericMapping OPTIONAL,\n  OUT PPRIVILEGE_SET      RequiredPrivilegesBuffer,\n  IN OUT PULONG           BufferLength,\n  OUT PACCESS_MASK        GrantedAccess,\n  OUT PNTSTATUS           AccessStatus );\n",
            "description": "\nFunction NtAccessCheck should be used by server\napplications working in SYSTEM context for check access to\nobject for connected client's token. See similar Win32 API\nAccessCheck in Microsoft SDK.\nSecurityDescriptor Pointer to SECURITY_DESCRIPTOR structure.\nClientToken HANDLE to client's\nToken Object opened with TOKEN_QUERY access.\nDesiredAccess ACCESS_MASK\nrequired by client.\nGenericMapping Pointer to\nGENERIC_MAPPING structure. Caller can take it in a call to\nNtQueryObject.\nRequiredPrivilegesBuffer Function fills\nthis buffer with structure PRIVILEGE_SET contains required\nprivileges.\nBufferLength Pointer to ULONG\nvalue. On input this value means size of RequiredPrivilegesBuffer buffer. If buffer\nwas to small, required buffer size is avaiable on output.\nGrantedAccess Pointer to\nACCESS_MASK value receiving granted access for object.\nAccessStatus Result of access check, in\ntypical NTSTATUS format.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtImpersonateClientOfPort\nNtImpersonateThread\nNtOpenProcessToken\nNtOpenThreadToken\nNtPrivilegeCheck\nNtQueryObject\nNtQuerySecurityObject\n"
      },
      "NtAllocateUuids": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtAllocateUuids(\n  OUT PLARGE_INTEGER      Time,\n  OUT PULONG              Range,\n  OUT PULONG              Sequence );\n",
            "description": "\nFunction NtAllocateUuids allocates User Unique\nIdentifier's base values. UUIDs are used to build unique\nSIDs.\nTime Returns current time.\nRange Returns allocation range.\n(???)\nSequence Returns allocation sequence.\n(???)\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtAllocateLocallyUniqueId\n"
      },
      "NtAllocateLocallyUniqueId": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtAllocateLocallyUniqueId(\n  OUT PLUID               LocallyUniqueId );\n",
            "description": "\nFunction allocates LUID (Locally Unique Identifier)\nfor future use.\nLocallyUniqueId Pointer to LUID\nstructure receiving new locally unique identifier.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtAllocateUuids\nNtCreateToken\n"
      },
      "NtQuerySecurityObject": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtQuerySecurityObject(\n  IN HANDLE               ObjectHandle,\n  IN SECURITY_INFORMATION SecurityInformationClass,\n  OUT PSECURITY_DESCRIPTOR DescriptorBuffer,\n  IN ULONG                DescriptorBufferLength,\n  OUT PULONG              RequiredLength );\n",
            "description": "\nFunction NtQuerySecurityObject retrieve object's\nSecurity Descriptor.\nObjectHandle HANDLE to any\nobject opened with READ_CONTROL access.\nSecurityInformationClass Can be\ncombination of:\nOWNER_SECURITY_INFORMATION\nGROUP_SECURITY_INFORMATION\nDACL_SECURITY_INFORMATION\nSACL_SECURITY_INFORMATION\nDescriptorBuffer Result of call -\npointer to SECURITY_DESCRIPTOR structure.\nDescriptorBufferLength Size of buffer,\nin bytes.\nRequiredLength Pointer to value\nreceiving required length of buffer.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtSetSecurityObject\nSECURITY_DESCRIPTOR\n"
      },
      "NtGetTickCount": {
            "code": "\nNTSYSAPI \nULONG\nNTAPI\nNtGetTickCount(\n );\n",
            "description": "\nFunction NtGetTickCount returns system Timer's\nticks counter. This counter is also avaiable in KUSER_SHARED_DATA structure as\nTickCountLow member.\nCalling NtSetTimerResolution\ndoesn't effect in counter's update resolution.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nKUSER_SHARED_DATA\nNtSetTimerResolution\n"
      },
      "NtQuerySystemTime": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtQuerySystemTime(\n  OUT PLARGE_INTEGER      SystemTime );\n",
            "description": "\nFunction NtQuerySystemTime returns current time in\nCoordinated Universal Time (UTC) 8-bytes format.\nSystemTime Pointer to\nLARGE_INTEGER value receiving current time.\nUTC time it's represented as 8 bytes length integer.\nThis value means number of 100-nanosecond units since\n1600, 1 January.\nTime is incremented 10.000.000 times per second. So\n64-bit counter overloads after about 58.426 years...\n(If you don't believe, check this).\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtSetSystemTime\nRtlTimeFieldsToTime\nRtlTimeToTimeFields\n"
      },
      "RtlTimeToTimeFields": {
            "code": "\nNTSYSAPI \nVOID\nNTAPI\nRtlTimeToTimeFields(\n  IN PLARGE_INTEGER       Time,\n  OUT PTIME_FIELDS        TimeFields );\n",
            "description": "\nFunction RtlTimeToTimeFields converts 64-bit\ntime to user-readable structure TIME_FIELDS.\nTime Pointer to LARGE_INTEGER\ncontains time to convert.\nTimeFields Result of call - pointer to\nTIME_FIELDS\nstructure.\n\nDocumented by:\nReactos\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nRtlTimeFieldsToTime\nTIME_FIELDS\n"
      },
      "NtQueryTimerResolution": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtQueryTimerResolution(\n  OUT PULONG              MinimumResolution,\n  OUT PULONG              MaximumResolution,\n  OUT PULONG              CurrentResolution );\n",
            "description": "\nFunction NtQueryTimerResolution returns resolution of\nsystem Timer in context of calling process. See also\ndescription of NtSetTimerResolution.\nMinimumResolution Means highest\npossible delay (in 100-ns units) between timer events.\nMaximumResolution Means lowest possible\ndelay (in 100-ns units) between timer events.\nCurrentResolution Current timer\nresolution, in 100-ns units.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtGetTickCount\nNtSetTimer\nNtSetTimerResolution\n"
      },
      "TIME_FIELDS": {
            "code": "\ntypedef struct _TIME_FIELDS {\n  USHORT                  Year;\n  USHORT                  Month;\n  USHORT                  Day;\n  USHORT                  Hour;\n  USHORT                  Minute;\n  USHORT                  Second;\n  USHORT                  Milliseconds;\n  USHORT                  Weekday;\n} TIME_FIELDS, *PTIME_FIELDS;\n",
            "description": "\nTIME_FIELDS structure is NTDLL version of\nWin 32 API SYSTEM_TIME. It contains detailed\ninformation about date and time.\nYear Year, in range 1601 -\n65535.\nMonth Month, in range 1 -\n12.\nDay Day, in range 1 - 31,\ndependly on Month member.\nHour Hour, in range 0 -\n23.\nMinute Minute, in range 0 -\n59.\nSecond Second, in range 0 -\n59.\nMilliseconds Milliseconds, in range\n0 - 1000.\nWeekday Day of week, in range 0 -\n6, where 0 means \"Sunday\",\n1 means \"Monday\" etc.\n\nDocumented by:\nReactos\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtQuerySystemTime\nNtSetSystemTime\nRtlTimeFieldsToTime\nRtlTimeToTimeFields\n"
      },
      "NtSetSystemTime": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtSetSystemTime(\n  IN PLARGE_INTEGER       SystemTime,\n  OUT PLARGE_INTEGER      PreviousTime OPTIONAL );\n",
            "description": "\nFunction NtSetSystemTime sets system time. See\nNtQuerySystemTime\nfor detailed information.\nSystemTime Pointer to\nLARGE_INTEGER contains UTC time to set.\nPreviousTime Optionally receives time\nbefore change.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\nPrivilege: SE_SYSTEMTIME_PRIVILEGE\n\nSee also:\nNtQuerySystemTime\nRtlTimeFieldsToTime\nRtlTimeToTimeFields\n"
      },
      "NtSetTimerResolution": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtSetTimerResolution(\n  IN ULONG                DesiredResolution,\n  IN BOOLEAN              SetResolution,\n  OUT PULONG              CurrentResolution );\n",
            "description": "\nFunction NtSetTimerResolution sets resolution of\nsystem Timer in calling process context.\nDesiredResolution Resolution to set. To\nreceive minimum and maximum resolution values, call NtQueryTimerResolution.\nSetResolution If set, system\nTimer's resolution is set to DesiredResolution value. If no, parameter\nDesiredResolution is\nignored.\nCurrentResolution Pointer to\nULONG value receiving current timer's resolution, in\n100-ns units.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtGetTickCount\nNtQueryTimerResolution\nNtSetTimer\n"
      },
      "NtQueryPerformanceCounter": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtQueryPerformanceCounter(\n  OUT PLARGE_INTEGER      PerformanceCounter,\n  OUT PLARGE_INTEGER      PerformanceFrequency OPTIONAL );\n",
            "description": "\nPerformanceCounter Result is number of\nprocessor ticks after last reset.\nPerformanceFrequency It's number of\nprocessor ticks per one second.\nAnother method of uptime calculation :\nUpTime = PerformanceCounter / PerformanceFrequency;\n\nDocumented by:\nSven B. Schreiber\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\n"
      },
      "RtlTimeFieldsToTime": {
            "code": "\nNTSYSAPI \nBOOLEAN\nNTAPI\nRtlTimeFieldsToTime(\n  IN PTIME_FIELDS         TimeFields,\n  OUT PLARGE_INTEGER      Time );\n",
            "description": "\nFunction RtlTimeFieldsToTime converts user-readable\nstructure TIME_FIELDS\nto 64-bit integer.\nTimeFields Pointer to TIME_FIELDS\nstructure containing time to convert.\nTime Pointer to LARGE_INTEGER\nreceiving converted time.\nSee also oposite function RtlTimeToTimeFields.\n\nDocumented by:\nReactos\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nRtlTimeToTimeFields\nTIME_FIELDS\n"
      },
      "NtSetSystemInformation": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtSetSystemInformation(\n  IN SYSTEM_INFORMATION_CLASS SystemInformationClass,\n  IN PVOID                SystemInformation,\n  IN ULONG                SystemInformationLength );\n",
            "description": "\nNtSetSystemInformation is used to set some\nunaccessable KernelMode variables. See also \nNtQuerySystemInformation.\nSystemInformationClass Information\nclass described in SYSTEM_INFORMATION_CLASS.\nSystemInformation Pointer to data\nbuffer to set.\nSystemInformationLength Length of\ninformation in SystemInformation\nbuffer, in bytes.\n\nDocumented by:\nSven B. Schreiber\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtQuerySystemInformation\nSYSTEM_INFORMATION_CLASS\n"
      },
      "NtQuerySystemInformation": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtQuerySystemInformation(\n  IN SYSTEM_INFORMATION_CLASS SystemInformationClass,\n  OUT PVOID               SystemInformation,\n  IN ULONG                SystemInformationLength,\n  OUT PULONG              ReturnLength OPTIONAL );\n",
            "description": "\nNtQuerySystemInformation is used to check some system\ninformations avaiable only in KernelMode (above\n0x80000000). All avaiable (or all known) information classes\nare described in SYSTEM_INFORMATION_CLASS.\nSystemInformationClass Information\nclass (see SYSTEM_INFORMATION_CLASS).\nSystemInformation User-allocated buffer\nfor results. Sometimes this parameter can be NULL\n(OPTIONAL), if you check required buffer size (see\nbelow).\nSystemInformationLength Length of\nSystemInformation buffer (in\nbytes).\nReturnLength Required length of\nSystemInformation buffer.\n\nDocumented by:\nSven B. Schreiber\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtSetSystemInformation\nSYSTEM_INFORMATION_CLASS\n"
      },
      "SYSTEM_INFORMATION_CLASS": {
            "code": "\ntypedef enum _SYSTEM_INFORMATION_CLASS {\n    SystemBasicInformation,\n    SystemProcessorInformation,\n    SystemPerformanceInformation,\n    SystemTimeOfDayInformation,\n    SystemPathInformation,\n    SystemProcessInformation,\n    SystemCallCountInformation,\n    SystemDeviceInformation,\n    SystemProcessorPerformanceInformation,\n    SystemFlagsInformation,\n    SystemCallTimeInformation,\n    SystemModuleInformation,\n    SystemLocksInformation,\n    SystemStackTraceInformation,\n    SystemPagedPoolInformation,\n    SystemNonPagedPoolInformation,\n    SystemHandleInformation,\n    SystemObjectInformation,\n    SystemPageFileInformation,\n    SystemVdmInstemulInformation,\n    SystemVdmBopInformation,\n    SystemFileCacheInformation,\n    SystemPoolTagInformation,\n    SystemInterruptInformation,\n    SystemDpcBehaviorInformation,\n    SystemFullMemoryInformation,\n    SystemLoadGdiDriverInformation,\n    SystemUnloadGdiDriverInformation,\n    SystemTimeAdjustmentInformation,\n    SystemSummaryMemoryInformation,\n    SystemNextEventIdInformation,\n    SystemEventIdsInformation,\n    SystemCrashDumpInformation,\n    SystemExceptionInformation,\n    SystemCrashDumpStateInformation,\n    SystemKernelDebuggerInformation,\n    SystemContextSwitchInformation,\n    SystemRegistryQuotaInformation,\n    SystemExtendServiceTableInformation,\n    SystemPrioritySeperation,\n    SystemPlugPlayBusInformation,\n    SystemDockInformation,\n    SystemPowerInformation,\n    SystemProcessorSpeedInformation,\n    SystemCurrentTimeZoneInformation,\n    SystemLookasideInformation\n} SYSTEM_INFORMATION_CLASS, *PSYSTEM_INFORMATION_CLASS;\n",
            "description": "\nEnumeration type SYSTEM_INFORMATION_CLASS defines\ninformation classes for a lot of system settings. This type is used\nwith function \nNtQuerySystemInformation and \nNtSetSystemInformation. For detailed informations see\ndescriptions of structures associated with information classes\nbelow.\nSystemBasicInformation\nAction\n: Query\nBuffer size\n: 0x02C\nStructure\n: SYSTEM_BASIC_INFORMATION\nSystemProcessorInformation\nAction\n: Query\nBuffer size\n: 0x00C\nStructure\n: SYSTEM_PROCESSOR_INFORMATION\nSystemPerformanceInformation 0x138 GET\nSystemTimeOfDayInformation 0x020 GET\nSystemPathInformation\nAction\n: Query\nBuffer size\n: ???\nStructure\n: STATUS_NOT_IMPLEMENTED\nSystem path is avaiable via structure KUSER_SHARED_DATA\nSystemProcessInformation\nAction\n: Query\nBuffer size\n: 0x088+\nStructure\n: SYSTEM_PROCESS_INFORMATION\nSystemCallCountInformation\nAction\n: Query\nBuffer size\n: 0x018+\nStructure\n: SYSTEM_CALL_COUNT_INFORMATION\nSystemDeviceInformation 0x018 GET\nSystemConfigurationInformation\nSystemProcessorPerformanceInformation\nAction\n: Query\nBuffer size\n: 0x030\nStructure\n: SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION\nSystemFlagsInformation 0x004 GET SET\nSystemCallTimeInformation NOT_IMPLEMENTED\nSystemModuleInformation\nAction\n: Query\nBuffer size\n: 0x106+\nStructure\n: SYSTEM_MODULE_INFORMATION\nSystemLocksInformation 0x028+ GET\nSystemStackTraceInformation 0x05C GET\nSystemPagedPoolInformation 0x01C GET checked build only\nSystemNonPagedPoolInformation 0x01C GET checked build only\nSystemHandleInformation\nAction\n: Query\nBuffer size\n: 0x014+\nStructure\n: SYSTEM_HANDLE_INFORMATION\nSystemObjectInformation\nAction\n: Query\nBuffer size\n: 0x038+\nStructure\n: SYSTEM_OBJECT_INFORMATION\nSystemPageFileInformation\nAction\n: Query\nBuffer size\n: 0x018+\nStructure\n: SYSTEM_PAGEFILE_INFORMATION\nSystemVdmInstemulInformation 0x088 GET\nSystemVdmBopInformation INVALID_INFO_CLASS\nSystemFileCacheInformation 0x00C, 0x024 GET SET\nSystemPoolTagInformation 0x020+ GET\nSystemInterruptInformation 0x018 GET\nSystemDpcBehaviorInformation 0x014 GET SET\nSystemFullMemoryInformation 0x014 GET checked build only\nSystemLoadGdiDriverInformation 0x018 SET\nSystemUnloadGdiDriverInformation 0x004 SET\nSystemTimeAdjustmentInformation\nAction\n: Query\nBuffer size\n: 0x00C\nStructure\n: SYSTEM_QUERY_TIME_ADJUST_INFORMATION\nAction\n: Set\nBuffer size\n: 0x008\nStructure\n: SYSTEM_SET_TIME_ADJUST_INFORMATION\nSystemSummaryMemoryInformation 0x014 GET checked build\nonly\nSystemNextEventIdInformation ???? (C0000005) GET checked build\nonly\nSystemEventIdsInformation 0xB66 GET checked build only\nSystemCrashDumpInformation 0x004 GET\nSystemExceptionInformation 0x010 GET\nSystemCrashDumpStateInformation 0x004 GET\nSystemKernelDebuggerInformation 0x002 GET\nSystemContextSwitchInformation 0x030 GET\nSystemRegistryQuotaInformation\nAction\n: Query\nBuffer size\n: 0x00C\nStructure\n: SYSTEM_REGISTRY_QUOTA_INFORMATION\nAction\n: Set\nBuffer size\n: 0x00C\nStructure\n: SYSTEM_REGISTRY_QUOTA_INFORMATION\nSystemExtendServiceTableInformation\nAction\n: Set\nBuffer size\n: 0x008\nStructure\n: SYSTEM_LOAD_IMAGE_INFORMATION\nSystemPrioritySeperation 0x004 SET\nSystemPlugPlayBusInformation NOT_IMPLEMENTED, GET\nSystemDockInformation NOT_IMPLEMENTED, GET\nSystemPowerInformation INVALID_INFO_CLASS\nSystemProcessorSpeedInformation INVALID_INFO_CLASS\nSystemCurrentTimeZoneInformation 0x0AC GET\nSystemLookasideInformation 0x000 GET\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtQuerySystemInformation\nNtSetSystemInformation\n"
      },
      "SYSTEM_PROCESS_INFORMATION": {
            "code": "\ntypedef struct _SYSTEM_PROCESS_INFORMATION {\n  ULONG                   NextEntryOffset;\n  ULONG                   NumberOfThreads;\n  LARGE_INTEGER           Reserved[3];\n  LARGE_INTEGER           CreateTime;\n  LARGE_INTEGER           UserTime;\n  LARGE_INTEGER           KernelTime;\n  UNICODE_STRING          ImageName;\n  KPRIORITY               BasePriority;\n  HANDLE                  ProcessId;\n  HANDLE                  InheritedFromProcessId;\n  ULONG                   HandleCount;\n  ULONG                   Reserved2[2];\n  ULONG                   PrivatePageCount;\n  VM_COUNTERS             VirtualMemoryCounters;\n  IO_COUNTERS             IoCounters;\n  SYSTEM_THREAD           Threads[0];\n} SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;\n",
            "description": "\nStructure SYSTEM_PROCESS_INFORMATION contains list of\nprocesses and threads and it's avaiable via \nNtQuerySystemInformation function with SystemProcessInformation\ninformation class.\nNextEntryOffset Offset from begining of\noutput buffer to next process entry. On last entry contains\nzero.\nNumberOfThreads Number of process'es\nthreads. Also number of members in Threads array descripted below.\nReserved[3] Reserved.\nCreateTime Process creation time, in\n100-ns units.\nUserTime Effective time in User\nMode.\nKernelTime Effective time in Kernel\nMode.\nImageName Process name, based on\nexecutable file name.\nBasePriority Process base\npriority.\nProcessId Unique identifier of\nprocess.\nInheritedFromProcessId Creator's\nidentifier.\nHandleCount Nr of open\nHANDLEs.\nReserved2[2] Reserved.\nPrivatePageCount Number of memory pages\nassigned to process.\nVirtualMemoryCounters Memory\nperformance counters.\nIoCounters IO performance\ncounters.\nThreads[0] Array of \nSYSTEM_THREAD structures descripting process's threads.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtQuerySystemInformation\nSYSTEM_INFORMATION_CLASS\nSYSTEM_THREAD\n"
      },
      "SYSTEM_THREAD": {
            "code": "\ntypedef struct _SYSTEM_THREAD {\n  LARGE_INTEGER           KernelTime;\n  LARGE_INTEGER           UserTime;\n  LARGE_INTEGER           CreateTime;\n  ULONG                   WaitTime;\n  PVOID                   StartAddress;\n  CLIENT_ID               ClientId;\n  KPRIORITY               Priority;\n  LONG                    BasePriority;\n  ULONG                   ContextSwitchCount;\n  ULONG                   State;\n  KWAIT_REASON            WaitReason;\n} SYSTEM_THREAD, *PSYSTEM_THREAD;\n",
            "description": "\nStructure SYSTEM_THREAD is a part of SYSTEM_PROCESS_INFORMATION\nstructure avaiable by \nNtQuerySystemInformation with \nSystemProcessInformation enumeration type.\nKernelTime  Sum of thread's execution\ntime in KernelMode, in native\nformat.\nUserTime Sum of thread's execution time\nin UserMode, in native\nformat.\nCreateTime Time of thread creation, in\nnative format.\nWaitTime  Sum of thread's waiting time,\nin native format.\nStartAddress  Thread start\naddress.\nClientId  Process and thread\nidentyficators.\nPriority  Thread prioryty.\nBasePriority  Thread base\nprioryty.\nContextSwitchCount  Number of context\nswitches executed by thread.\nState  Current thread's state.\nWaitReason  Reason for waiting (if\nany).\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtQuerySystemInformation\nSYSTEM_PROCESS_INFORMATION\n"
      },
      "SYSTEM_PAGEFILE_INFORMATION": {
            "code": "\ntypedef struct _SYSTEM_PAGEFILE_INFORMATION {\n  ULONG                   NextEntryOffset;\n  ULONG                   TotalSize;\n  ULONG                   TotalInUse;\n  ULONG                   PeakUsage;\n  UNICODE_STRING          PageFileName;\n} SYSTEM_PAGEFILE_INFORMATION, *PSYSTEM_PAGEFILE_INFORMATION;\n",
            "description": "\nStructure SYSTEM_PAGEFILE_INFORMATION is used as a\nresult of call \nNtQuerySystemInformation with SystemPageFileInformation\ninformation class. If contains information about currently instaled\nPaged Files (files used by system for swap paged pool memory to\ndisk).\nNextEntryOffset Offset to next\nSYSTEM_PAGEFILE_INFORMATION structure or zero, if\nit's last one.\nTotalSize Size of paged file, in pages\n(Size of page depend on machine type, for x86 one\npage is 0x1000 (4096) bytes).\nTotalInUse Number of currently used\npages in paged file.\nPeakUsage Maximum number of pages used\nin this boot session.\nPageFileName System path to paged\nfile.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCreatePagingFile\nNtQuerySystemInformation\nSYSTEM_INFORMATION_CLASS\n"
      },
      "RtlDecompressBuffer": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nRtlDecompressBuffer(\n  IN ULONG                CompressionFormat,\n  OUT PVOID               DestinationBuffer,\n  IN ULONG                DestinationBufferLength,\n  IN PVOID                SourceBuffer,\n  IN ULONG                SourceBufferLength,\n  OUT PULONG              pDestinationSize );\n",
            "description": "\nCompressionFormat\n"
      },
      "RtlCompressBuffer": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nRtlCompressBuffer(\n  IN ULONG                CompressionFormat,\n  IN PVOID                SourceBuffer,\n  IN ULONG                SourceBufferLength,\n  OUT PVOID               DestinationBuffer,\n  IN ULONG                DestinationBufferLength,\n  IN ULONG                Unknown,\n  OUT PULONG              pDestinationSize,\n  IN PVOID                WorkspaceBuffer );\n",
            "description": "\nCompressionFormat\n"
      },
      "RtlGetCompressionWorkSpaceSize": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nRtlGetCompressionWorkSpaceSize(\n  IN ULONG                CompressionFormat,\n  OUT PULONG              pNeededBufferSize,\n  OUT PULONG              pUnknown );\n",
            "description": "\nCompressionFormat\n"
      },
      "RtlReAllocateHeap": {
            "code": "\nNTSYSAPI \nPVOID\nNTAPI\nRtlReAllocateHeap(\n  IN PVOID                HeapHandle,\n  IN ULONG                Flags,\n  IN PVOID                MemoryPointer,\n  IN ULONG                Size );\n",
            "description": "\nKernel32.dll HeapReAlloc maps directly to RtlReAllocateHeap. All parameters are descripted in Ms SDK.\n"
      },
      "RtlSizeHeap": {
            "code": "\nNTSYSAPI \nULONG\nNTAPI\nRtlSizeHeap(\n  IN PVOID                HeapHandle,\n  IN ULONG                Flags,\n  IN PVOID                MemoryPointer );\n",
            "description": "\nKernel32.dll HeapSize maps directly to RtlSizeHeap. See Ms SDK for definition.\n"
      },
      "RtlValidateProcessHeaps": {
            "code": "\nNTSYSAPI \nBOOLEAN\nNTAPI\nRtlValidateProcessHeaps(\n );\n",
            "description": "\nFunction validate all heaps associated with calling process. See RtlValidateHeap for more information.\n"
      },
      "RtlAllocateHeap": {
            "code": "\nNTSYSAPI \nPVOID\nNTAPI\nRtlAllocateHeap(\n  IN PVOID                HeapHandle,\n  IN ULONG                Flags,\n  IN ULONG                Size );\n",
            "description": "\nFunction maps Win32 API HeapCreate, see Ms SDK.\n"
      },
      "RtlCompactHeap": {
            "code": "\nNTSYSAPI \nULONG\nNTAPI\nRtlCompactHeap(\n  IN HANDLE               HeapHandle,\n  IN ULONG                Flags );\n",
            "description": "\nHeapHandle\nHeap address.\n"
      },
      "RtlFreeHeap": {
            "code": "\nNTSYSAPI \nBOOLEAN\nNTAPI\nRtlFreeHeap(\n  IN PVOID                HeapHandle,\n  IN ULONG                Flags OPTIONAL,\n  IN PVOID                MemoryPointer );\n",
            "description": "\nMaps directly to Win32 API HeapFree from Kernel32.dll.\n"
      },
      "RtlValidateHeap": {
            "code": "\nNTSYSAPI \nBOOLEAN\nNTAPI\nRtlValidateHeap(\n  IN PVOID                HeapHandle,\n  IN ULONG                Flags,\n  IN PVOID                AddressToValidate OPTIONAL );\n",
            "description": "\n"
      },
      "RtlLockHeap": {
            "code": "\nNTSYSAPI \nBOOLEAN\nNTAPI\nRtlLockHeap(\n  IN PVOID                HeapHandle );\n",
            "description": "\n"
      },
      "RtlProtectHeap": {
            "code": "\nNTSYSAPI \nPVOID\nNTAPI\nRtlProtectHeap(\n  IN PVOID                HeapHandle,\n  IN BOOLEAN              Protect );\n",
            "description": "\nHeapHandle\nAddress of heap.\n"
      },
      "RtlUnlockHeap": {
            "code": "\nNTSYSAPI \nBOOLEAN\nNTAPI\nRtlUnlockHeap(\n  IN PVOID                HeapHandle );\n",
            "description": "\n"
      },
      "RtlGetProcessHeaps": {
            "code": "\nNTSYSAPI \nULONG\nNTAPI\nRtlGetProcessHeaps(\n  IN ULONG                MaxNumberOfHeaps,\n  OUT PVOID               *HeapArray );\n",
            "description": "\nMaxNumberOfHeaps\nSize of HeapArray.\n"
      },
      "RtlWalkHeap": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nRtlWalkHeap(\n  IN PVOID                HeapHandle,\n  IN OUT LPPROCESS_HEAP_ENTRY ProcessHeapEntry );\n",
            "description": "\nHeapHandle\nAddress of heap.\n"
      },
      "RtlEnumProcessHeaps": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nRtlEnumProcessHeaps(\n  IN PHEAP_ENUMERATION_ROUTINE HeapEnumerationRoutine,\n  IN PVOID                Param OPTIONAL );\n",
            "description": "\nPHEAP_ENUMERATION_ROUTINE is defined as follows:\ntypedef NTSTATUS \n(*PHEAP_ENUMERATION_ROUTINE)(\n                IN PVOID HeapHandle,\n                IN PVOID UserParam\n                );\n"
      },
      "RtlDestroyHeap": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nRtlDestroyHeap(\n  IN PVOID               HeapHandle );\n",
            "description": "\nHeapHandle\nPointer to heap memory block.\n"
      },
      "RtlCreateHeap": {
            "code": "\nNTSYSAPI \nPVOID\nNTAPI\nRtlCreateHeap(\n  IN ULONG                Flags,\n  IN PVOID                Base OPTIONAL,\n  IN ULONG                Reserve OPTIONAL,\n  IN ULONG                Commit,\n  IN BOOLEAN              Lock OPTIONAL,\n  IN PRTL_HEAP_DEFINITION RtlHeapParams OPTIONAL );\n",
            "description": "\nFlags\nFlags are defined in &lt;WinNT.h&gt;. Can be one of following:\n     HEAP_NO_SERIALIZE\n        HEAP_GROWABLE\n        HEAP_GENERATE_EXCEPTIONS\n        HEAP_ZERO_MEMORY\n        HEAP_REALLOC_IN_PLACE_ONLY\n        HEAP_TAIL_CHECKING_ENABLED\n        HEAP_FREE_CHECKING_ENABLED\n        HEAP_DISABLE_COALESCE_ON_FREE\n        HEAP_CREATE_ALIGN_16\n        HEAP_CREATE_ENABLE_TRACING\n"
      },
      "NtQueryVirtualMemory": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtQueryVirtualMemory(\n  IN HANDLE               ProcessHandle,\n  IN PVOID                BaseAddress,\n  IN MEMORY_INFORMATION_CLASS MemoryInformationClass,\n  OUT PVOID               Buffer,\n  IN ULONG                Length,\n  OUT PULONG              ResultLength OPTIONAL );\n",
            "description": "\nFunction NtQueryVirtualMemory retrieves parameters of\nqueried memory block.\nProcessHandle HANDLE to process\ncontaining queried address in process'es address space.\nBaseAddress Virtual address to\nquery.\nMemoryInformationClass Information\nclass defined in MEMORY_INFORMATION_CLASS\nenumeration type. Currently only one class is supported.\nBuffer As long as only MemoryBasicInformation is\nsupported, this value points to structure\nMEMORY_BASIC_INFORMATION, defined in\n&lt;WINNT.h&gt; and described in MS SDK.\nLength Length of Buffer, in bytes.\nResultLength Optionally pointer to\nULONG value receiving required size of Buffer, in bytes.\n\nDocumented by:\nTomasz Nowak\nReactos\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nMEMORY_BASIC_INFORMATION\nMEMORY_INFORMATION_CLASS\nNtAllocateVirtualMemory\nNtFreeVirtualMemory\nNtLockVirtualMemory\nNtProtectVirtualMemory\n"
      },
      "MEMORY_BASIC_INFORMATION": {
            "code": "\ntypedef struct _MEMORY_BASIC_INFORMATION {\n  PVOID                   BaseAddress;\n  PVOID                   AllocationBase;\n  ULONG                   AllocationProtect;\n  ULONG                   RegionSize;\n  ULONG                   State;\n  ULONG                   Protect;\n  ULONG                   Type;\n} MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;\n",
            "description": "\nStructure MEMORY_BASIC_INFORMATION is returned as a\nreselt of call \nNtQueryVirtualMemory with MemoryBasicInformation\ninformation class. It's also descripted in Ms SDK.\nBaseAddress Address of queried memory\npage.\nAllocationBase Base address of\nallocation. It's different (typically less) to BaseAddress when\nuser allocate more then one page length memory block, and change\nattributes of a part of allocated block.\nAllocationProtect Access type on memory\nallocation. Can be one or combination of following attributes:\nPAGE_NOACCESS\nPAGE_READONLY\nPAGE_READWRITE\nPAGE_WRITECOPY\nPAGE_EXECUTE\nPAGE_EXECUTE_READ\nPAGE_EXECUTE_READWRITE\nPAGE_EXECUTE_WRITECOPY\nPAGE_GUARD\nPAGE_NOCACHE\nPAGE_WRITECOMBINE\nRegionSize Size of queried region, in\nbytes.\nState State of memory block. Can be one\nof:\nMEM_RESERVE\nMEM_COMMIT\nMEM_FREE\nProtect Current protection of queried\nmemory block. Can be one or combination of values listed for\nAllocationProtect member.\nType Type of queried memory block. Can\nbe one of:\nMEM_PRIVATE - Queried block was allocated by call\nNtAllocateVirtualMemory,\nMEM_MAPPED - Queried block is memory mapped Section\nObject,\nSEC_IMAGE - Queried block is Section Object representing\nexecutable image file in memory.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nMEMORY_INFORMATION_CLASS\nNtAllocateVirtualMemory\nNtProtectVirtualMemory\nNtQueryVirtualMemory\n"
      },
      "NtAllocateVirtualMemory": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtAllocateVirtualMemory(\n  IN HANDLE               ProcessHandle,\n  IN OUT PVOID            *BaseAddress,\n  IN ULONG                ZeroBits,\n  IN OUT PULONG           RegionSize,\n  IN ULONG                AllocationType,\n  IN ULONG                Protect );\n",
            "description": "\n"
      },
      "NtUnlockVirtualMemory": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtUnlockVirtualMemory(\n  IN HANDLE               ProcessHandle,\n  IN PVOID                *BaseAddress,\n  IN OUT PULONG           NumberOfBytesToUnlock,\n  IN ULONG                LockType );\n",
            "description": "\nSee NtLockVirtualMemory for more information about parameters and usage.\n"
      },
      "NtReadVirtualMemory": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtReadVirtualMemory(\n  IN HANDLE               ProcessHandle,\n  IN PVOID                BaseAddress,\n  OUT PVOID               Buffer,\n  IN ULONG                NumberOfBytesToRead,\n  OUT PULONG              NumberOfBytesReaded OPTIONAL );\n",
            "description": "\nNtReadVirtualMemory is similar to API ReadProcessMemory, described in MS SDK.\n"
      },
      "NtLockVirtualMemory": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtLockVirtualMemory(\n  IN HANDLE               ProcessHandle,\n  IN PVOID                *BaseAddress,\n  IN OUT PULONG           NumberOfBytesToLock,\n  IN ULONG                LockOption );\n",
            "description": "\nLockOption\nCan be one or both of following values:\n        #define VM_LOCK_1                0x0001   // This is used, when calling KERNEL32.DLL VirtualLock routine\n    #define VM_LOCK_2                0x0002   // This require SE_LOCK_MEMORY_NAME privilege\n"
      },
      "MEMORY_INFORMATION_CLASS": {
            "code": "\ntypedef enum _MEMORY_INFORMATION_CLASS {\n    MemoryBasicInformation\n} MEMORY_INFORMATION_CLASS, *PMEMORY_INFORMATION_CLASS;\n",
            "description": "\nEnumeration type MEMORY_INFORMATION_CLASS specify\ntype of information returned in a call to \nNtQueryVirtualMemory function. Currently only one class is\ndefined.\nMemoryBasicInformation Result buffer\ncontains structure \nMEMORY_BASIC_INFORMATION.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nMEMORY_BASIC_INFORMATION\nNtQueryVirtualMemory\n"
      },
      "NtFlushVirtualMemory": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtFlushVirtualMemory(\n  IN HANDLE               ProcessHandle,\n  IN OUT PVOID            *BaseAddress,\n  IN OUT PULONG           NumberOfBytesToFlush,\n  OUT PIO_STATUS_BLOCK    IoStatusBlock );\n",
            "description": "\nNtFlushVirtualMemory flushes mapped section view to\nfile.\nProcessHandle HANDLE of process\ncontaining mapped view of section to flush.\n*BaseAddress Pointer to PVOID\nvalue containing address of memory area to flush. On output this\nvalue is rounded to Page Size (0x1000).\nNumberOfBytesToFlush Pointer to\nULONG value specifing length of area to flush. On output\nthis value is rounded up to Page Size (0x1000).\nIoStatusBlock Pointer to\nIO_STATUS_BLOCK structure. After call Information member\ncontains the same value as NumberOfBytesToFlush parameter.\nWARNING: Two (or more) memory pages mapped in different\ncalls of \nNtMapViewOfSection cannot be flushed in one function call, even\nif both has the same SECTION as a source.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCreateSection\nNtMapViewOfSection\nNtOpenSection\nNtUnmapViewOfSection\n"
      },
      "NtWriteVirtualMemory": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtWriteVirtualMemory(\n  IN HANDLE               ProcessHandle,\n  IN PVOID                BaseAddress,\n  IN PVOID                Buffer,\n  IN ULONG                NumberOfBytesToWrite,\n  OUT PULONG              NumberOfBytesWritten OPTIONAL );\n",
            "description": "\nNtWriteVirtualMemory is similar to WINAPI WriteProcessMemory. See Ms SDK for detailed description of parameters.\n"
      },
      "NtProtectVirtualMemory": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtProtectVirtualMemory(\n  IN HANDLE               ProcessHandle,\n  IN OUT PVOID            *BaseAddress,\n  IN OUT PULONG           NumberOfBytesToProtect,\n  IN ULONG                NewAccessProtection,\n  OUT PULONG              OldAccessProtection );\n",
            "description": "\n"
      },
      "NtFreeVirtualMemory": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtFreeVirtualMemory(\n  IN HANDLE               ProcessHandle,\n  IN PVOID                *BaseAddress,\n  IN OUT PULONG           RegionSize,\n  IN ULONG                FreeType );\n",
            "description": "\nRegionSize\nIf you put pointer to NULL value as RegionSize, system will free all region, and put size of it in result.\n"
      },
      "NtOpenThreadToken": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtOpenThreadToken(\n  IN HANDLE               ThreadHandle,\n  IN ACCESS_MASK          DesiredAccess,\n  IN BOOLEAN              OpenAsSelf,\n  OUT PHANDLE             TokenHandle ); \n",
            "description": "\nThreadHandle HANDLE to thread\nobject.\nDesiredAccess Access mask for opened\nToken Object.\nOpenAsSelf - ???\nTokenHandle Result of call -\nHANDLE to Token Object associated with ThreadHandle thread.\nUsually Win32 threads don't have associated Tokens. If you want to\nassociate Token for Thread Object, use NtSetInformationThread\nwith ThreadImpersonationToken\ninformation class.\n\nDocumented by:\nTomasz Nowak\nReactos\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCreateToken\nNtOpenProcessToken\nNtOpenThread\nNtSetInformationThread\nTHREAD_INFORMATION_CLASS\n"
      },
      "NtDuplicateToken": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtDuplicateToken(\n  IN HANDLE               ExistingToken,\n  IN ACCESS_MASK          DesiredAccess,\n  IN POBJECT_ATTRIBUTES   ObjectAttributes OPTIONAL,\n  IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,\n  IN TOKEN_TYPE           TokenType,\n  OUT PHANDLE             NewToken );\n",
            "description": "\nFunction NtDuplicateToken creates new Token Object\nbasing on existing Token Object.\nExistingToken HANDLE to Token\nObject opened with TOKEN_DUPLICATE access.\nDesiredAccess Access mask for newly\ncreated token. Can be combination of:\nTOKEN_ASSIGN_PRIMARY\nTOKEN_DUPLICATE\nTOKEN_IMPERSONATE\nTOKEN_QUERY\nTOKEN_QUERY_SOURCE\nTOKEN_ADJUST_PRIVILEGES\nTOKEN_ADJUST_GROUPS\nTOKEN_ADJUST_DEFAULT\nTOKEN_ADJUST_SESSIONID\nObjectAttributes Optionally pointer to\nOBJECT_ATTRIBUTES structure, containing token's name.\nImpersonationLevel Level of\nimpersonation for new token.\nTokenType Type of new token.\nNewToken Result of call - pointer to\nHANDLE to new Token Object.\n\nDocumented by:\nTomasz Nowak\nReactos\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCreateToken\nNtOpenProcessToken\nNtOpenThreadToken\nNtQueryInformationToken\nNtSetInformationToken\n"
      },
      "NtAdjustPrivilegesToken": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtAdjustPrivilegesToken(\n  IN HANDLE               TokenHandle,\n  IN BOOLEAN              DisableAllPrivileges,\n  IN PTOKEN_PRIVILEGES    TokenPrivileges,\n  IN ULONG                PreviousPrivilegesLength,\n  OUT PTOKEN_PRIVILEGES   PreviousPrivileges OPTIONAL,\n  OUT PULONG              RequiredLength OPTIONAL );\n",
            "description": "\nFunction NtAdjustPrivilegesToken is used to modify\nstate of avaiable token's privileges, and it's descripted also in\nMicrosoft SDK help as\nAdjustTokenPrivileges.\nTokenHandle HANDLE to Token\nObject opened with TOKEN_ADJUST_PRIVILEGES access. If\nPreviousPrivileges parameter is\nnon-NULL, also TOKEN_QUERY access is required.\nDisableAllPrivileges If set, all\naccessable privileges are disabled, and rest of parameters below\nare ignored.\nTokenPrivileges Pointer to TOKEN_PRIVILEGES structure containing\narray of privileges to adjust.\nPreviousPrivilegesLength Length of\nPreviousPrivileges buffer, in\nbytes.\nPreviousPrivileges Optionally pointer\nto TOKEN_PRIVILEGES structure\nfilled by function with previous state of privileges specified by\nTokenPrivileges array.\nRequiredLength If PreviousPrivileges buffer was to small, this\nparameter point to required size.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtAdjustGroupsToken\nNtCreateToken\nNtOpenProcessToken\nNtOpenThreadToken\nNtPrivilegeCheck\nNtQueryInformationToken\nTOKEN_PRIVILEGES\n"
      },
      "NtQueryInformationToken": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtQueryInformationToken(\n  IN HANDLE               TokenHandle,\n  IN TOKEN_INFORMATION_CLASS TokenInformationClass,\n  OUT PVOID               TokenInformation,\n  IN ULONG                TokenInformationLength,\n  OUT PULONG              ReturnLength );\n",
            "description": "\nFunction NtQueryInformationToken receives\ninformations specified by information class from Token Object. See\nalso Win32 API GetTokenInformation.\nTokenHandle HANDLE to Token\nObject opened with TOKEN_QUERY access.\nTokenInformationClass Information class\ndescripted in TOKEN_INFORMATION_CLASS\ntopic.\nTokenInformation User's allocated\nbuffer for output data. Format of output buffer depends on\nTokenInformationClass\nparameter.\nTokenInformationLength Length of\nTokenInformation buffer, in\nbytes.\nReturnLength If output buffer is to\nsmall, value under this parameter receives required length.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCreateToken\nNtOpenProcessToken\nNtOpenThreadToken\nNtSetInformationToken\nTOKEN_INFORMATION_CLASS\n"
      },
      "NtCreateToken": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtCreateToken(\n  OUT PHANDLE             TokenHandle,\n  IN ACCESS_MASK          DesiredAccess,\n  IN POBJECT_ATTRIBUTES   ObjectAttributes,\n  IN TOKEN_TYPE           TokenType,\n  IN PLUID                AuthenticationId,\n  IN PLARGE_INTEGER       ExpirationTime,\n  IN PTOKEN_USER          TokenUser,\n  IN PTOKEN_GROUPS        TokenGroups,\n  IN PTOKEN_PRIVILEGES    TokenPrivileges,\n  IN PTOKEN_OWNER         TokenOwner,\n  IN PTOKEN_PRIMARY_GROUP TokenPrimaryGroup,\n  IN PTOKEN_DEFAULT_DACL  TokenDefaultDacl,\n  IN PTOKEN_SOURCE        TokenSource );\n",
            "description": "\nFunction NtCreateToken creates Token Object.\nTokenHandle Result of call - pointer to\nHANDLE to Token Object.\nDesiredAccess Can be one or more of\nfollowing:\nTOKEN_ASSIGN_PRIMARY\nTOKEN_DUPLICATE\nTOKEN_IMPERSONATE\nTOKEN_QUERY\nTOKEN_QUERY_SOURCE\nTOKEN_ADJUST_PRIVILEGES\nTOKEN_ADJUST_GROUPS\nTOKEN_ADJUST_DEFAULT\nTOKEN_ADJUST_SESSIONID\nTOKEN_ALL_ACCESS\nObjectAttributes Pointer to\nOBJECT_ATTRIBUTES structure.\nTokenType (?), see\nTOKEN_TYPE enumeration type.\nAuthenticationId (?), see\nNtAllocateLocallyUniqueId security function.\nExpirationTime (?),\npointer to LARGE_INTEGER value contains time in\n100-ns format.\nTokenUser (?), see\nTOKEN_USER structure.\nTokenGroups (?), see\nTOKEN_GROUPS structure.\nTokenPrivileges (?), see\nTOKEN_PRIVILEGES\nstructure.\nTokenOwner (?), see\nTOKEN_OWNER structure.\nTokenPrimaryGroup (?),\nsee TOKEN_PRIMARY_GROUP\nstructure.\nTokenDefaultDacl (?), see\nTOKEN_DEFAULT_DACL\nstructure.\nTokenSource (?), see\nTOKEN_SOURCE structure.\n\nDocumented by:\nReactos\nRequirements:\n\nLibrary: ntdll.lib\nPrivilege: SE_CREATE_TOKEN_PRIVILEGE\n\nSee also:\nNtAllocateLocallyUniqueId\nNtDuplicateToken\nNtOpenProcessToken\nNtOpenThreadToken\nNtQueryInformationToken\nNtSetInformationToken\n"
      },
      "NtSetInformationToken": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtSetInformationToken(\n  IN HANDLE               TokenHandle,\n  IN TOKEN_INFORMATION_CLASS TokenInformationClass,\n  OUT PVOID               TokenInformation,\n  IN ULONG                TokenInformationLength );\n",
            "description": "\nFunction NtSetInforamtionToken sets parameters of\nToken Objects. See also description of SetTokenInformation\nin Win32 API SDK.\nTokenHandle HANDLE to Token\nObject opened with TOKEN_ADJUST_DEFAULT access.\nTokenInformationClass Information class\ndescripted in TOKEN_INFORMATION_CLASS\ntopic.\nTokenInformation User's allocated\nbuffer containing data to set to.\nTokenInformationLength Length of\nTokenInformation buffer, in\nbytes.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCreateToken\nNtOpenProcessToken\nNtOpenThreadToken\nNtQueryInformationToken\nTOKEN_INFORMATION_CLASS\n"
      },
      "NtPrivilegeCheck": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtPrivilegeCheck(\n  IN HANDLE               TokenHandle,\n  IN PPRIVILEGE_SET       RequiredPrivileges,\n  IN PBOOLEAN             Result );\n",
            "description": "\nFunction NtPrivilegeCheck is used to check state of\nany privileges in Token Object. It's also descripted in\nMicrosoft SDK as PrivilegeCheck.\nTokenHandle HANDLE to Token\nObject opened with TOKEN_QUERY access.\nRequiredPrivileges Pointer to PRIVILEGE_SET structure contains\ndefinitions of privileges to check.\nResult Result of call - pointer to\nBOOLEAN value containing TRUE is all asked privileges\nare enabled.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtAdjustPrivilegesToken\nNtCreateToken\nNtOpenProcessToken\nNtOpenThreadToken\nPRIVILEGE_SET\n"
      },
      "NtAdjustGroupsToken": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtAdjustGroupsToken(\n  IN HANDLE               TokenHandle,\n  IN BOOLEAN              ResetToDefault,\n  IN PTOKEN_GROUPS        TokenGroups,\n  IN ULONG                PreviousGroupsLength,\n  OUT PTOKEN_GROUPS       PreviousGroups OPTIONAL,\n  OUT PULONG              RequiredLength OPTIONAL );\n",
            "description": "\nFunction NtAdjustGroupsToken modify state of one or\nmore groups avaialbe for Token Object. See also description of\nsimilar Win32 API AdjustTokenGroups in Win32\nSDK.\nTokenHandle HANDLE to Token\nObject opened with TOKEN_ADJUST_GROUPS access.\nResetToDefault If set, groups are reset\nto token's defaults. In this case all other parameters are\nignored.\nTokenGroups Pointer to TOKEN_GROUPS structure containing groups to\nmodify.\nPreviousGroupsLength Specifies length\nof PreviousGroups buffer, in\nbytes.\nPreviousGroups Optionally pointer to\nTOKEN_GROUPS buffer receiving\ninformation about modified groups before modification begins.\nRequiredLength If PreviousGroups parameter is specified, and\nPreviousGroupsLength is to\nsmall, this value receives required length of buffer, in bytes.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtAdjustPrivilegesToken\nNtCreateToken\nNtOpenProcessToken\nNtOpenThreadToken\nNtQueryInformationToken\nNtSetInformationToken\nTOKEN_GROUPS\n"
      },
      "NtOpenProcessToken": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtOpenProcessToken(\n  IN HANDLE               ProcessHandle,\n  IN ACCESS_MASK          DesiredAccess,\n  OUT PHANDLE             TokenHandle );\n",
            "description": "\nProcessHandle HANDLE to Process\nObject.\nDesiredAccess Access mask for opened\nToken Object.\nTokenHandle Result of call -\nHANDLE to Token Object associated with process specified by\nProcessHandle parameter.\nSee also PROCESS_INFORMATION_CLASS with\nProcessAccessToken\ninformation class.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCreateToken\nNtOpenThreadToken\nNtQueryInformationProcess\nNtSetInformationProcess\nPROCESS_INFORMATION_CLASS\n"
      },
      "NtCreateIoCompletion": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtCreateIoCompletion(\n  OUT PHANDLE             IoCompletionHandle,\n  IN ACCESS_MASK          DesiredAccess,\n  IN POBJECT_ATTRIBUTES   ObjectAttributes OPTIONAL,\n  IN ULONG                NumberOfConcurrentThreads );\n",
            "description": "\nFunction NtCreateIoCompletion creates IO Completion\nObject. IO Completion Object is used for waiting on pending IO\noperation (reading or writing) in multi-process file access. It\ncontains more informations about IO operation than synchronization\nevent or APC Routine.\nIoCompletionHandle Result of call -\nHANDLE to newly created IO Completion Object.\nDesiredAccess Access mask for created\nHANDLE. Can be combination of:\nIO_COMPLETION_QUERY_STATE\nIO_COMPLETION_MODIFY_STATE\nIO_COMPLETION_ALL_ACCESS\nObjectAttributes Optionally contains\nobject name, in Objects Namespace.\nNumberOfConcurrentThreads Number of\nthreads accessing File Object associated with IO Completion. If\nZero, system reserves memory for number of threads equal to current\nnymber of processes.\n\nDocumented by:\nTomasz Nowak\nReactos\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nFILE_INFORMATION_CLASS\nNtOpenIoCompletion\nNtQueryIoCompletion\nNtRemoveIoCompletion\nNtSetInformationFile\nNtSetIoCompletion\n"
      },
      "IO_COMPLETION_INFORMATION_CLASS": {
            "code": "\ntypedef enum _IO_COMPLETION_INFORMATION_CLASS {\n    IoCompletionBasicInformation\n} IO_COMPLETION_INFORMATION_CLASS, *PIO_COMPLETION_INFORMATION_CLASS;\n",
            "description": "\nEnumeration type IO_COMPLETION_INFORMATION_CLASS is\nused with \nNtQueryIoCompletion function to get information about IO\nCompletion object. Currently only one information class is\ndefined.\nIoCompletionBasicInformation Buffer\nreceiving data is descripted as \nIO_COMPLETION_BASIC_INFORMATION structure and has 0x04\nbytes length.\n\nDocumented by:\nTomasz Nowak\nBo Branten\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nIO_COMPLETION_BASIC_INFORMATION\nNtQueryIoCompletion\n"
      },
      "NtQueryIoCompletion": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtQueryIoCompletion(\n  IN HANDLE               IoCompletionHandle,\n  IN IO_COMPLETION_INFORMATION_CLASS InformationClass,\n  OUT PVOID               IoCompletionInformation,\n  IN ULONG                InformationBufferLength,\n  OUT PULONG              RequiredLength OPTIONAL );\n",
            "description": "\nFunction NtQueryIoCompletion receives number of file\noperations pending on specified IO Completion Object.\nIoCompletionHandle HANDLE to IO\nCompletion Object opened with IO_COMPLETION_QUERY_STATE\naccess.\nInformationClass See IO_COMPLETION_INFORMATION_CLASS\nfor possible values.\nIoCompletionInformation User's\nallocated buffer for result data.\nInformationBufferLength Length of\nIoCompletionInformation buffer,\nin bytes.\nRequiredLength Optionally receives\nrequired length of buffer.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nIO_COMPLETION_INFORMATION_CLASS\nNtCreateIoCompletion\nNtOpenIoCompletion\nNtRemoveIoCompletion\nNtSetIoCompletion\n"
      },
      "NtSetIoCompletion": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtSetIoCompletion(\n  IN HANDLE               IoCompletionHandle,\n  IN ULONG                CompletionKey,\n  OUT PIO_STATUS_BLOCK    IoStatusBlock,\n  IN NTSTATUS             CompletionStatus,\n  IN ULONG                NumberOfBytesTransfered );\n",
            "description": "\nFunction NtSetIoCompletion increments pending IO\ncounter in IO Completion Object. It can be used to manual finish IO\noperation.\nIoCompletionHandle HANDLE to IO\nCompletion Object opened with IO_COMPLETION_MODIFY_STATE\naccess.\nCompletionKey User's defined key\nreceived by \nNtRemoveIoCompletion function.\nIoStatusBlock IO result of call.\nCompletionStatus IO operation\nstatus.\nNumberOfBytesTransfered Number of bytes\ntransfered in manually finished IO operation.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCreateIoCompletion\nNtOpenIoCompletion\nNtQueryIoCompletion\nNtRemoveIoCompletion\n"
      },
      "IO_COMPLETION_BASIC_INFORMATION": {
            "code": "\ntypedef struct _IO_COMPLETION_BASIC_INFORMATION {\n  ULONG                   Depth;\n} IO_COMPLETION_BASIC_INFORMATION, *PIO_COMPLETION_BASIC_INFORMATION;\n",
            "description": "\nStructure IO_COMPLETION_BASIC_INFORMATION is used as\nresult of call \nNtQueryIoCompletion with \nIoCompletionBasicInformation information class.\nDepth Number of currently pending file\noperations for specified IO Completion Object.\n\nDocumented by:\nTomasz Nowak\nBo Branten\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nIO_COMPLETION_INFORMATION_CLASS\nNtQueryIoCompletion\n"
      },
      "NtOpenIoCompletion": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtOpenIoCompletion(\n  OUT PHANDLE             IoCompletionHandle,\n  IN ACCESS_MASK          DesiredAccess,\n  IN POBJECT_ATTRIBUTES   ObjectAttributes );\n",
            "description": "\nFunction NtOpenIoCompletion opens existing IO\nCompletion Object. IO Completion must be created as named\nobject.\nIoCompletionHandle Result of call -\npointer to HANDLE value.\nDesiredAccess Can be one or combination\nof:\nIO_COMPLETION_QUERY_STATE\nIO_COMPLETION_MODIFY_STATE\nIO_COMPLETION_ALL_ACCESS\nObjectAttributes Pointer to\nOBJECT_ATTRIBUTES structure containing valid IO Completion\nname.\n\nDocumented by:\nTomasz Nowak\nReactos\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCreateIoCompletion\n"
      },
      "NtRemoveIoCompletion": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtRemoveIoCompletion(\n  IN HANDLE               IoCompletionHandle,\n  OUT PULONG              CompletionKey,\n  OUT PULONG              CompletionValue,\n  OUT PIO_STATUS_BLOCK    IoStatusBlock,\n  IN PLARGE_INTEGER       Timeout OPTIONAL );\n",
            "description": "\nFunction NtRemoveIoCompletion is one of waiting calls\nand it's finished when at least one completion record will be\navaiable in specified Io Completion object. Records are\nadded when I/O operation is finished, but previously File\nobject have to been associated with Io Completion\nobject.\nAssociation between File and Io Completion objects is\nmaded by call to \nNtSetInformationFile with \nFileCompletionInformation information class. Additionally every\nassotiation have to have unique Key defined. This\nfunctionality allows to use one Io Completion object with\ndifferent File objects.\nEvery one File object can have only one Io Completion\nassociated with it.\nI/O operations won't be appended to Io Completion object\nexcept file operations will be called with non-zero value in\nApcContext parameters.\nIoCompletionHandle HANDLE to\npreviously created or opened Io Completion object.\nCompletionKey Receives completion\nKey informing about File object who finishes\nI/O.\nCompletionValue Value of ApcContext file operation parameter.\nCompletionValue informs about\noperation finished.\nIoStatusBlock Io status of finished\noperation.\nTimeout Optionally pointer to time out\nvalue.\nSupported on system versions:\nNT 4.0,Win 2000,Win XP/2003\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nFILE_COMPLETION_INFORMATION\nFILE_INFORMATION_CLASS\nNtCreateIoCompletion\nNtOpenIoCompletion\nNtReadFile\nNtSetInformationFile\nNtSetIoCompletion\nNtWriteFile\n"
      },
      "SECTION_INFORMATION_CLASS": {
            "code": "\ntypedef enum _SECTION_INFORMATION_CLASS {\n    SectionBasicInformation,\n    SectionImageInformation\n} SECTION_INFORMATION_CLASS, *PSECTION_INFORMATION_CLASS;\n",
            "description": "\nEnumeration type SECTION_INFORMATION_CLASS is used in\na call to \nNtQuerySection function.\nThis type can be one of:\nSectionBasicInformation Result buffer\ncontains structure SECTION_BASIC_INFORMATION.\nBuffer size shoud be set to 0x0C.\nSectionImageInformation Result buffer\ncontains structure SECTION_IMAGE_INFORMATION.\nBuffer size shoud be set to 0x28. This information class is\naccessable only where section was created with HANDLE to\nopen executable file (see \nNtCreateSection for details).\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCreateSection\nNtOpenSection\nNtQuerySection\nSECTION_BASIC_INFORMATION\nSECTION_IMAGE_INFORMATION\n"
      },
      "NtOpenSection": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtOpenSection(\n  OUT PHANDLE             SectionHandle,\n  IN ACCESS_MASK          DesiredAccess,\n  IN POBJECT_ATTRIBUTES   ObjectAttributes );\n",
            "description": "\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCreateSection\n"
      },
      "SECTION_INHERIT": {
            "code": "\ntypedef enum _SECTION_INHERIT {\n    ViewShare=1,\n    ViewUnmap=2\n} SECTION_INHERIT, *PSECTION_INHERIT;\n",
            "description": "\nEnumeration type SECTION_INHERIT is used in a call to\nNtMapViewOfSection.\nViewShare Created view of Section\nObject will be also mapped to any created in future process.\nViewUnmap Created view will not be\ninherited by child processes.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtMapViewOfSection\n"
      },
      "NtCreateSection": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtCreateSection(\n  OUT PHANDLE             SectionHandle,\n  IN ULONG                DesiredAccess,\n  IN POBJECT_ATTRIBUTES   ObjectAttributes OPTIONAL,\n  IN PLARGE_INTEGER       MaximumSize OPTIONAL,\n  IN ULONG                PageAttributess,\n  IN ULONG                SectionAttributes,\n  IN HANDLE               FileHandle OPTIONAL );\n",
            "description": "\nFunction NtCreateSection creates Section Object\n(virtual memory block with associated file).\nSectionHandle Result of call -\nHANDLE to Section Object.\nDesiredAccess Access mask. Can be\ncombination of:\nSECTION_QUERY\nSECTION_MAP_WRITE\nSECTION_MAP_READ\nSECTION_MAP_EXECUTE\nSECTION_EXTEND_SIZE\nSECTION_ALL_ACCESS\nObjectAttributes Pointer to\nOBJECT_ATTRIBUTES structure contains section name, in Object\nNamespace format.\nMaximumSize Optionally define maximum\nsize of section. Must be defined when caller create section based\non system PageFile.\nPageAttributess Can be one or\ncombination of:\nPAGE_NOACCESS\nPAGE_READONLY\nPAGE_READWRITE\nPAGE_WRITECOPY\nPAGE_EXECUTE\nPAGE_EXECUTE_READ\nPAGE_EXECUTE_READWRITE\nPAGE_EXECUTE_WRITECOPY\nPAGE_GUARD\nPAGE_NOCACHE\nPAGE_WRITECOMBINE\nSectionAttributes Can be one or\ncombination of:\nSEC_FILE\nSEC_IMAGE\nSEC_RESERVE\nSEC_COMMIT\nSEC_NOCACHE\nFileHandle Optionally HANDLE to\nFile Object opened with proper access.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCreateFile\nNtExtendSection\nNtFlushVirtualMemory\nNtMapViewOfSection\nNtOpenFile\nNtOpenSection\nNtQuerySection\n"
      },
      "NtQuerySection": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtQuerySection(\n  IN HANDLE               SectionHandle,\n  IN SECTION_INFORMATION_CLASS InformationClass,\n  OUT PVOID               InformationBuffer,\n  IN ULONG                InformationBufferSize,\n  OUT PULONG              ResultLength OPTIONAL );\n",
            "description": "\nInformationClass\nUse one of following:\n"
      },
      "NtUnmapViewOfSection": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtUnmapViewOfSection(\n  IN HANDLE               ProcessHandle,\n  IN PVOID                BaseAddress );\n",
            "description": "\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtMapViewOfSection\nNtOpenSection\n"
      },
      "NtMapViewOfSection": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtMapViewOfSection(\n  IN HANDLE               SectionHandle,\n  IN HANDLE               ProcessHandle,\n  IN OUT PVOID            *BaseAddress OPTIONAL,\n  IN ULONG                ZeroBits OPTIONAL,\n  IN ULONG                CommitSize,\n  IN OUT PLARGE_INTEGER   SectionOffset OPTIONAL,\n  IN OUT PULONG           ViewSize,\n  IN                      InheritDisposition,\n  IN ULONG                AllocationType OPTIONAL,\n  IN ULONG                Protect );\n",
            "description": "\nFunction NtMapViewOfSection maps specified part of\nSection Object into process memory.\nSectionHandle HANDLE to Section\nObject opened with one or more from SECTION_MAP_EXECUTE,\nSECTION_MAP_READ, SECTION_MAP_WRITE attributes.\nProcessHandle HANDLE to Process\nObject opened with PROCESS_VM_OPERATION access.\n*BaseAddress Pointer to variable\nreceiving virtual address of mapped memory. If this value is not\nNULL, system tries to allocate memory from specified\nvalue.\nZeroBits Indicates how many high bits\nmust not be set in BaseAddress.\nCommitSize Size of initially commited\nmemory, in bytes.\nSectionOffset Pointer to begin of\nmapped block in section. This value must be rounded up to\nX64K block size (0x10000 on X86).\nViewSize Pointer to size of mapped\nblock, in bytes. This value is rounded up to page size\n(0x1000 on x86).\nInheritDisposition How to child\nprocesses inherid maped section. See description of enumeration\ntype \nSECTION_INHERIT.\nAllocationType Can be one of:\nMEM_COMMIT\nMEM_RESERVE\nProtect Page protection. Can be one\nof:\nPAGE_NOACCESS\nPAGE_READONLY\nPAGE_READWRITE\nPAGE_WRITECOPY\nPAGE_EXECUTE\nPAGE_EXECUTE_READ\nPAGE_EXECUTE_READWRITE\nPAGE_EXECUTE_WRITECOPY\nPAGE_GUARD\nPAGE_NOCACHE\nPAGE_WRITECOMBINE\nSupported on system versions:\nNT 4.0,Win 2000,Win XP/2003\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtAllocateVirtualMemory\nNtCreateSection\nNtOpenSection\nNtUnmapViewOfSection\n"
      },
      "NtExtendSection": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtExtendSection(\n  IN HANDLE               SectionHandle,\n  IN PLARGE_INTEGER       NewSectionSize );\n",
            "description": "\nSectionHandle\n"
      },
      "OBJECT_WAIT_TYPE": {
            "code": "\ntypedef enum _OBJECT_WAIT_TYPE {\n    WaitAllObject,\n    WaitAnyObject\n} OBJECT_WAIT_TYPE, *POBJECT_WAIT_TYPE;\n",
            "description": "\nOBJECT_WAIT_TYPE is used in a call to NtWaitForMultipleObjects.\nWaitAllObject All objects specified in\nwaiting function must be signaled to continue execution.\nWaitAnyObject At least one of specified\nobjects must be signaled. Return value indicates position of\nsignaled object in object's array. STATUS_WAIT_0 indicates\nfirst element in object's array, STATUS_WAIT_1 is the second\netc.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtWaitForMultipleObjects\n"
      },
      "NtDuplicateObject": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtDuplicateObject(\n  IN HANDLE               SourceProcessHandle,\n  IN PHANDLE              SourceHandle,\n  IN HANDLE               TargetProcessHandle,\n  OUT PHANDLE             TargetHandle,\n  IN ACCESS_MASK          DesiredAccess OPTIONAL,\n  IN BOOLEAN              InheritHandle,\n  IN ULONG                Options );\n",
            "description": "\nSee Microsoft SDK for description of DuplicateHandle Win32 API. \n"
      },
      "NtWaitForSingleObject": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtWaitForSingleObject(\n  IN HANDLE               ObjectHandle,\n  IN BOOLEAN              Alertable,\n  IN PLARGE_INTEGER       TimeOut OPTIONAL );  \n",
            "description": "\nObjectHandle HANDLE to alertable\nobject.\nAlertable If set, calling thread is\nsignaled, so all queued APC routines are executed.\nTimeOut Time-out interval, in\nmicroseconds. NULL means infinite.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtSignalAndWaitForSingleObject\nNtWaitForMultipleObjects\n"
      },
      "NtSetInformationObject": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtSetInformationObject(\n  IN HANDLE               ObjectHandle,\n  IN OBJECT_INFORMATION_CLASS ObjectInformationClass,\n  IN PVOID                ObjectInformation,\n  IN ULONG                Length );\n",
            "description": "\n"
      },
      "NtQueryObject": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtQueryObject(\n  IN HANDLE               ObjectHandle,\n  IN OBJECT_INFORMATION_CLASS ObjectInformationClass,\n  OUT PVOID               ObjectInformation,\n  IN ULONG                Length,\n  OUT PULONG              ResultLength );\n",
            "description": "\nFunction NtQueryObject retrives some informations\nabout any or all objects opened by calling process. It can be used\nwith any type of object.\nObjectHandle HANDLE to object.\nObjectInformationClass Kind of\ninformation to retrive. See \nOBJECT_INFORMATION_CLASS for possible values list.\nObjectInformation Output buffer\nallocated by caller.\nLength Length of ObjectInformation buffer, in bytes.\nResultLength Pointer to ULONG\nvalue that contains required size of ObjectInformation buffer after function\ncall.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtSetInformationObject\nOBJECT_INFORMATION_CLASS\n"
      },
      "NtSignalAndWaitForSingleObject": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtSignalAndWaitForSingleObject(\n  IN HANDLE               ObjectToSignal,\n  IN HANDLE               WaitableObject,\n  IN BOOLEAN              Alertable,\n  IN PLARGE_INTEGER       Time OPTIONAL );\n",
            "description": "\nFunction NtSignalAndWaitForSingleObject signals one\nobject and wait for second object. See also Win32 API\nSignalObjectAndWait description in Microsoft SDK.\nObjectToSignal HANDLE to object\nto signal. Possible object's types are:\nEvent Object\nSemaphore Object\nMutant Object\nWaitableObject HANDLE to object\nto wait for. Can be any waitable object.\nAlertable If set, APC Routine\ncan break waiting.\nTime Optionally pointer to\nLARGE_INTEGER value specifing time (absolute or relative)\nwhen function time outs (in 100-ns units). Negative value\nmeans relative time.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCreateEvent\nNtCreateMutant\nNtCreateSemaphore\nNtWaitForMultipleObjects\nNtWaitForSingleObject\n"
      },
      "NtWaitForMultipleObjects": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtWaitForMultipleObjects(\n  IN ULONG                ObjectCount,\n  IN PHANDLE              ObjectsArray,\n  IN OBJECT_WAIT_TYPE     WaitType,\n  IN BOOLEAN              Alertable,\n  IN PLARGE_INTEGER       TimeOut OPTIONAL );\n",
            "description": "\nObjectCount Number of objects in\nObjectsArray array.\nObjectsArray Pointer to array of\nHANDLE. Each must be opened with SYNCHRONIZE\naccess.\nWaitType Can be WaitAllObjects or\nWaitAnyObject.\nAlertable If set, thread is signaled\n(APC routines queued for this thread are executed).\nTimeOut Time-out interval.\nNtWaitForMultipleObjects is used typically to\nresponse for notyfications. For synchronization purposes you should\nuse NtWaitForSingleObject.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtSignalAndWaitForSingleObject\nNtWaitForSingleObject\nOBJECT_WAIT_TYPE\n"
      },
      "OBJECT_BASIC_INFORMATION": {
            "code": "\ntypedef struct _OBJECT_BASIC_INFORMATION {\n  ULONG                   Attributes;\n  ACCESS_MASK             DesiredAccess;\n  ULONG                   HandleCount;\n  ULONG                   ReferenceCount;\n  ULONG                   PagedPoolUsage;\n  ULONG                   NonPagedPoolUsage;\n  ULONG                   Reserved[3];\n  ULONG                   NameInformationLength;\n  ULONG                   TypeInformationLength;\n  ULONG                   SecurityDescriptorLength;\n  LARGE_INTEGER           CreationTime;\n} OBJECT_BASIC_INFORMATION, *POBJECT_BASIC_INFORMATION;\n",
            "description": "\nStructure OBJECT_BASIC_INFORMATION is returned in a\nresult of call \nNtQueryObject with \nObjectBasicInformation information class.\nAttributes \nDesiredAccess \nHandleCount \nReferenceCount \nPagedPoolUsage \nNonPagedPoolUsage \nReserved[3] \nNameInformationLength \nTypeInformationLength \nSecurityDescriptorLength \nCreationTime \nSupported on system versions:\nNT 4.0,Win 2000,Win XP/2003\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtQueryObject\nOBJECT_INFORMATION_CLASS\n"
      },
      "NtClose": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtClose(\n  IN HANDLE               ObjectHandle );\n",
            "description": "\nObjectHandle\n"
      },
      "NtMakeTemporaryObject": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtMakeTemporaryObject(\n  IN HANDLE               ObjectHandle );\n",
            "description": "\n(Also avaiable in Win2000 DDK)\nFunction clears object's PERMANENT flag, so it's live as\nlong as the latest HANDLE is closed.\nObjectHandle HANDLE to object to\nmake temporary.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtClose\nNtQueryObject\n"
      },
      "OBJECT_INFORMATION_CLASS": {
            "code": "\ntypedef enum _OBJECT_INFORMATION_CLASS {\n    ObjectBasicInformation,\n    ObjectNameInformation,\n    ObjectTypeInformation,\n    ObjectAllInformation,\n    ObjectDataInformation\n} OBJECT_INFORMATION_CLASS, *POBJECT_INFORMATION_CLASS;\n",
            "description": "\nOBJECT_INFORMATION_CLASS specifies a kind of\ninformation of any object available in caller context. It's used\nwith functions NtQueryObject and\nNtSetInformationObject.\nObjectBasicInformation\nAction\n: Query\nBuffer size\n: 0x038\nStructure\n: OBJECT_BASIC_INFORMATION\nObjectNameInformation\nAction\n: Query\nBuffer size\n: 0x08\nStructure\n: OBJECT_NAME_INFORMATION\nObjectTypeInformation\nAction\n: Query\nBuffer size\n: 0x070\nStructure\n: OBJECT_TYPE_INFORMATION\nObjectAllInformation\nAction\n: Query\nBuffer size\n: 0x04+\nStructure\n: OBJECT_ALL_INFORMATION\nComment\n: Size of buffer depends on number of objects opened by\ncaller.\nObjectDataInformation\nAction\n: Query, Set\nBuffer size\n: 0x02\nStructure\n: OBJECT_DATA_INFORMATION\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtQueryObject\nNtSetInformationObject\n"
      },
      "NtCreateDebugObject": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtCreateDebugObject(\n  OUT PHANDLE             DebugObjectHandle,\n  IN ACCESS_MASK          DesiredAccess,\n  IN POBJECT_ATTRIBUTES   ObjectAttributes OPTIONAL,\n  IN BOOLEAN              KillProcessOnExit );\n",
            "description": "\nFunction NtCreateDebugObject is used for Debug\nObject creation. Debug Object it's a new\nfunctionality implemented in Windows XP and above as support\nfor debuging User Mode applications. In previous versions of\nNT debuging was implemented with Port objects (see \nNtCreatePort). Application can debug one or few different\napplications in the same time, but need to create as many\nDebug Objects as number of debuged processes.\nThere're two methods of start debugging. To start application in\ndebug mode, user need to use NtCreateProcessEx function (avaiable\non XP+) with HANDLE to previously created Debug\nObject. Or just attach debugger to working process by\ncalling \nNtDebugActiveProcess.\nDebugObjectHandle Pointer to newly\ncreated Debug Object HANDLE.\nDesiredAccess Access mask for Debug\nObject. Can be one or more of following:\nDEBUGOBJECT_WAIT_STATE_CHANGE\nDEBUGOBJECT_ADD_REMOVE_PROCESS\nDEBUGOBJECT_ALL_ACCESS\nObjectAttributes Optionally can define\nobject's name.\nKillProcessOnExit If set, debuged\nprocess will be terminated with closing Debug\nObject.\nSupported on system versions:\nWin XP/2003\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nDBG_STATE\nNtCreateProcessEx\nNtDebugActiveProcess\n"
      },
      "DBG_STATE": {
            "code": "\ntypedef enum _DBG_STATE {\n    DbgIdle,\n    DbgReplyPending,\n    DbgCreateThreadStateChange,\n    DbgCreateProcessStateChange,\n    DbgExitThreadStateChange,\n    DbgExitProcessStateChange,\n    DbgExceptionStateChange,\n    DbgBreakpointStateChange,\n    DbgSingleStepStateChange,\n    DbgLoadDllStateChange,\n    DbgUnloadDllStateChange\n} DBG_STATE, *PDBG_STATE;\n",
            "description": "\nDBG_STATE enumeration is used by Debug Objects\nas a member of DBGUI_WAIT_STATE_CHANGE\nstructure returned in successfull call to NtWaitForDebugEvent function. It\ndescribes current state of Debug Object. Possible values\nare:\nDbgIdle \nDbgReplyPending \nDbgCreateThreadStateChange \nDbgCreateProcessStateChange \nDbgExitThreadStateChange \nDbgExitProcessStateChange \nDbgExceptionStateChange \nDbgBreakpointStateChange \nDbgSingleStepStateChange \nDbgLoadDllStateChange \nDbgUnloadDllStateChange \nSupported on system versions:\nWin XP/2003\n\nDocumented by:\nReactos\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nDBGUI_WAIT_STATE_CHANGE\nNtWaitForDebugObject\n"
      },
      "NtDebugActiveProcess": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtDebugActiveProcess(\n  IN HANDLE               ProcessHandle,\n  IN HANDLE               DebugObjectHandle );\n",
            "description": "\nFunction NtDebugActiveProcess is used to attach\nDebug Object to any non-debuged process.\nProcessHandle HANDLE to process\nbeing debugged (opened with enough access rigths - see \nNtOpenProcess).\nDebugObjectHandle HANDLE to\npreviously created Debug Object.\nSupported on system versions:\nWin XP/2003\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCreateDebugObject\nNtOpenProcess\nNtRemoveProcessDebug\n"
      },
      "NtRemoveProcessDebug": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtRemoveProcessDebug(\n  IN HANDLE               ProcessHandle,\n  IN HANDLE               DebugObjectHandle );\n",
            "description": "\nFunction NtRemoveProcessDebug detach debugger from\nprocess. It's reverse of \nNtDebugActiveProcess function.\nProcessHandle HANDLE to process\nbeing debugged.\nDebugObjectHandle HANDLE to\nDebug Object.\nSupported on system versions:\nWin XP/2003\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCreateDebugObject\nNtDebugActiveProcess\n"
      },
      "FILE_BOTH_DIR_INFORMATION": {
            "code": "\ntypedef struct _FILE_BOTH_DIR_INFORMATION {\n  ULONG                   NextEntryOffset;\n  ULONG                   FileIndex;\n  LARGE_INTEGER           CreationTime;\n  LARGE_INTEGER           LastAccessTime;\n  LARGE_INTEGER           LastWriteTime;\n  LARGE_INTEGER           ChangeTime;\n  LARGE_INTEGER           EndOfFile;\n  LARGE_INTEGER           AllocationSize;\n  ULONG                   FileAttributes;\n  ULONG                   FileNameLength;\n  ULONG                   EaSize;\n  BYTE                    ShortNameLength;\n  WCHAR                   ShortName[12];\n  WCHAR                   FileName[1];\n} FILE_BOTH_DIR_INFORMATION, *PFILE_BOTH_DIR_INFORMATION;\n",
            "description": "\nStructure FILE_BOTH_DIR_INFORMATION is returned as a\nresult of call \nNtQueryDirectoryFile with \nFileBothDirectoryInformation information class. It's extended\nversion of FILE_FULL_DIR_INFORMATION\nstructure, additionallycontaining short file name. It's used\nin Win32 API calls FindFirstFile and\nFindNextFile.\nNextEntryOffset Offset (in bytes) of\nnext FILE_BOTH_DIR_INFORMATION structure placed in\nresult buffer. If there's no more entries, NextEntryOffset is set to zero.\nFileIndex File index value, or zero, if\ndirectory indexing is not avaiable.\nCreationTime Time of object\ncreation;\nLastAccessTime Last access time. Means\ntime when last open operation was performed.\nLastWriteTime Time of last write\ndata.\nChangeTime Time of last change.\nEndOfFile Specify length of file, in\nbytes.\nAllocationSize Specify real size of\nfile on device. It must be equal or greater to EndOfFile member.\nFileAttributes Attributes of file.\nFileNameLength Length of FileName array, in bytes.\nEaSize Size of Extended Attributes\nassociated with file. See also FILE_EA_INFORMATION\nstructure.\nShortNameLength Length ShortName array, in bytes.\nShortName[12] Alternate file name, in\nUNICODE format. Empty string means:\nPrimary name is compatible with 8DOT3 (MS\nDOS) standart, and there's no reason to set the same name\ntwice;\nFile system don't improve short names;\nFileName[1] UNICODE string specifing\nfile name.\n\nDocumented by:\nTomasz Nowak\nBo Branten\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nFILE_DIRECTORY_INFORMATION\nFILE_FULL_DIR_INFORMATION\nFILE_INFORMATION_CLASS\nFILE_NAME_INFORMATION\nFILE_NAMES_INFORMATION\nNtQueryDirectoryFile\nNtQueryOleDirectoryFile\n"
      },
      "FILE_FS_LABEL_INFORMATION": {
            "code": "\ntypedef struct _FILE_FS_LABEL_INFORMATION {\n  ULONG                   VolumeLabelLength;\n  WCHAR                   VolumeLabel[1];\n} FILE_FS_LABEL_INFORMATION, *PFILE_FS_LABEL_INFORMATION;\n",
            "description": "\nStructure is an input buffer for \nNtSetVolumeInformationFile call with information class \nFileFsLabelInformation.\nVolumeLabelLength Length of\nVolumeLabel array, in\nbytes.\nVolumeLabel[1] Label for specified\nvolume.\n\nDocumented by:\nBo Branten\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nFS_INFORMATION_CLASS\nNtSetVolumeInformationFile\n"
      },
      "NtCreateFile": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtCreateFile(\n  OUT PHANDLE             FileHandle,\n  IN ACCESS_MASK          DesiredAccess,\n  IN POBJECT_ATTRIBUTES   ObjectAttributes,\n  OUT PIO_STATUS_BLOCK    IoStatusBlock,\n  IN PLARGE_INTEGER       AllocationSize OPTIONAL,\n  IN ULONG                FileAttributes,\n  IN ULONG                ShareAccess,\n  IN ULONG                CreateDisposition,\n  IN ULONG                CreateOptions,\n  IN PVOID                EaBuffer OPTIONAL,\n  IN ULONG                EaLength );\n",
            "description": "\n(Avaiable also in 2000 DDK.)\nFileHandle Result of call -\nHANDLE to File Object.\nDesiredAccess Access mask based on\ndefinitions in schema FILE_* from\n&lt;WinNT.h&gt;.\nObjectAttributes Name of file to create\n(or open), optionally path in name string. You can also define root\ndirectory, security descriptor and attributes\nOBJ_CASE_INSENSITIVE and OBJ_INHERIT.\nIoStatusBlock Pointer to\nIO_STATUS_BLOCK structure, that receive final status of\nfunction call. Can be one of:\nFILE_CREATED\nFILE_OPENED\nFILE_OVERWRITTEN\nFILE_SUPERSEDED\nFILE_EXISTS\nFILE_DOES_NOT_EXIST\nAllocationSize File size after\ncreation.\nFileAttributes Attributes for newly\ncreated file, as follows:\nFILE_ATTRIBUTE_READONLY\nFILE_ATTRIBUTE_HIDDEN\nFILE_ATTRIBUTE_SYSTEM\nFILE_ATTRIBUTE_ARCHIVE\nFILE_ATTRIBUTE_NORMAL\nFILE_ATTRIBUTE_TEMPORARY\nFILE_ATTRIBUTE_OFFLINE\nFILE_ATTRIBUTE_NOT_CONTENT_INDEXED\nShareAccess Specifies share method for\nopened object. Can be set to zero or any combination of flags:\nFILE_SHARE_READ\nFILE_SHARE_WRITE\nFILE_SHARE_DELETE\nCreateDisposition Specifies disposition\nhow to create or open object and can be one of:\nFILE_SUPERSEDE - If file exists, deletes it before\ncreation of new one.\nFILE_OPEN - Fails, if file not exists.\nFILE_CREATE - Fails, if file exists.\nFILE_OPEN_IF - If file exists, opens it. If not, creates\nnew one and then open it.\nFILE_OVERWRITE - If file not exists, create and open it.\nIf exists, open them and reset content.\nFILE_OVERWRITE_IF - As FILE_OVERWRITE, but fails\nif file not exists.\nCreateOptions Creation options.\nEaBuffer Buffer for Extended Attributes\ncontains one or more of \nFILE_FULL_EA_INFORMATION structures.\nEaLength Length of EaBuffer.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nFILE_FULL_EA_INFORMATION\nNtDeleteFile\nNtOpenFile\nNtSetEaFile\n"
      },
      "NtDeleteFile": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtDeleteFile(\n  IN POBJECT_ATTRIBUTES   ObjectAttributes );\n",
            "description": "\nIt's very interesting NT System Call... Normally, file deletion is realised as FileDispositionInformation class in a call to NtSetInformationFile. When you use NtDeleteFile, file will be deleted immediatly after call (system isn't waiting for close last HANDLE to file).\n"
      },
      "FILE_INTERNAL_INFORMATION": {
            "code": "\ntypedef struct _FILE_INTERNAL_INFORMATION {\n  LARGE_INTEGER           IndexNumber;\n} FILE_INTERNAL_INFORMATION, *PFILE_INTERNAL_INFORMATION;\n",
            "description": "\nFILE_INTERNAL_INFORMATION structure is a result of\ncall \nNtQueryInformationFile with \nFileInternalInformation information class. It's not possible to\nset file unique identifier.\nIndexNumber File indentifier, unique\nfor file's device.\n\nDocumented by:\nTomasz Nowak\nBo Branten\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nFILE_ALL_INFORMATION\nFILE_INFORMATION_CLASS\nNtCreateFile\nNtOpenFile\nNtQueryInformationFile\n"
      },
      "FILE_NAMES_INFORMATION": {
            "code": "\ntypedef struct _FILE_NAMES_INFORMATION {\n  ULONG                   NextEntryOffset;\n  ULONG                   FileIndex;\n  ULONG                   FileNameLength;\n  WCHAR                   FileName[1];\n} FILE_NAMES_INFORMATION, *PFILE_NAMES_INFORMATION;\n",
            "description": "\nStructure FILE_NAMES_INFORMATION is used as a result\nof call \nNtQueryDirectoryFile with \nFileNamesInformation information class. It's shorter then other\ndirectory informational structures, so can be used for better\nperformance, when only file names are required.\nNextEntryOffset Offset (in bytes) of\nnext FILE_NAMES_INFORMATION entry, or zero if\nlast.\nFileIndex Index of file, or zero if\nDirectory Indexing is disabled.\nFileNameLength Length of FileName\narray, in bytes.\nFileName[1] Name of file, in UNICODE\nformat.\n\nDocumented by:\nTomasz Nowak\nBo Branten\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nFILE_BOTH_DIR_INFORMATION\nFILE_DIRECTORY_INFORMATION\nFILE_FULL_DIR_INFORMATION\nFILE_INFORMATION_CLASS\nNtQueryDirectoryFile\n"
      },
      "FILE_GET_EA_INFORMATION": {
            "code": "\ntypedef struct _FILE_GET_EA_INFORMATION {\n  ULONG                   NextEntryOffset;\n  BYTE                    EaNameLength;\n  CHAR                    EaName[1];\n} FILE_GET_EA_INFORMATION, *PFILE_GET_EA_INFORMATION;\n",
            "description": "\nStructure FILE_GET_EA_INFORMATION is used in a call\nto NtQueryEaFile function. See\nFILE_FULL_EA_INFORMATION for detailed information about\nEA.\nNextEntryOffset Relative offset for\nnext FILE_GET_EA_INFORMATION structure in\nbuffer.\nEaNameLength Length of EA name,\nin bytes (without leading zero).\nEaName[1] ASCIIZ name of\nEA, case insensitive.\n\nDocumented by:\nTomasz Nowak\nBo Branten\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nFILE_FULL_EA_INFORMATION\nNtQueryEaFile\n"
      },
      "NtDeviceIoControlFile": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtDeviceIoControlFile(\n  IN HANDLE               FileHandle,\n  IN HANDLE               Event OPTIONAL,\n  IN PIO_APC_ROUTINE      ApcRoutine OPTIONAL,\n  IN PVOID                ApcContext OPTIONAL,\n  OUT PIO_STATUS_BLOCK    IoStatusBlock,\n  IN ULONG                IoControlCode,\n  IN PVOID                InputBuffer OPTIONAL,\n  IN ULONG                InputBufferLength,\n  OUT PVOID               OutputBuffer OPTIONAL,\n  IN ULONG                OutputBufferLength );\n",
            "description": "\nFunction NtDeviceIoControlFile sends IOCTL_*\ncontrol code to Device Driver. It is primary (but not the best)\nsolution to communicate between application and Device Driver.\nFileHandle HANDLE to Device\nObject opened as a file.\nEvent Optional HANDLE to Event\nObject signalled on the end of processing request.\nApcRoutine Optional pointer to user's\nAPC Routine called on the end of processing request.\nApcContext User's parameter to\nApcRoutine.\nIoStatusBlock IO result of call.\nIoControlCode IO Control code\n[IOCTL_*].\nInputBuffer User's allocated buffer\nwith input data.\nInputBufferLength Length of\nInputBuffer, in bytes.\nOutputBuffer User's allocated buffer\nfor result data.\nOutputBufferLength Length of\nOutputBuffer, in bytes.\nSee also NtFsControlFile.\n\nDocumented by:\nTomasz Nowak\nReactos\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCreateFile\nNtFsControlFile\nNtOpenFile\n"
      },
      "FILE_INFORMATION_CLASS": {
            "code": "\ntypedef enum _FILE_INFORMATION_CLASS {\n    FileDirectoryInformation=1,\n    FileFullDirectoryInformation,\n    FileBothDirectoryInformation,\n    FileBasicInformation,\n    FileStandardInformation,\n    FileInternalInformation,\n    FileEaInformation,\n    FileAccessInformation,\n    FileNameInformation,\n    FileRenameInformation,\n    FileLinkInformation,\n    FileNamesInformation,\n    FileDispositionInformation,\n    FilePositionInformation,\n    FileFullEaInformation,\n    FileModeInformation,\n    FileAlignmentInformation,\n    FileAllInformation,\n    FileAllocationInformation,\n    FileEndOfFileInformation,\n    FileAlternateNameInformation,\n    FileStreamInformation,\n    FilePipeInformation,\n    FilePipeLocalInformation,\n    FilePipeRemoteInformation,\n    FileMailslotQueryInformation,\n    FileMailslotSetInformation,\n    FileCompressionInformation,\n    FileCopyOnWriteInformation,\n    FileCompletionInformation,\n    FileMoveClusterInformation,\n    FileQuotaInformation,\n    FileReparsePointInformation,\n    FileNetworkOpenInformation,\n    FileObjectIdInformation,\n    FileTrackingInformation,\n    FileOleDirectoryInformation,\n    FileContentIndexInformation,\n    FileInheritContentIndexInformation,\n    FileOleInformation,\n    FileMaximumInformation\n} FILE_INFORMATION_CLASS, *PFILE_INFORMATION_CLASS;\n",
            "description": "\nEnumeration type FILE_INFORMATION_CLASS defines\ninformational classes for File Objects. It's used by \nNtQueryInformationFile, \nNtQueryDirectoryFile and \nNtSetInformationFile functions.\nFileDirectoryInformation=1\nAction\n: Query\nBuffer size\n: 0x48\nStructure\n: FILE_DIRECTORY_INFORMATION\nFunction\n: NtQueryDirectoryFile\nFileFullDirectoryInformation\nAction\n: Query\nBuffer size\n: 0x48\nStructure\n: FILE_FULL_DIR_INFORMATION\nFunction\n: NtQueryDirectoryFile\nFileBothDirectoryInformation\nAction\n: Query\nBuffer size\n: 0x48\nStructure\n: FILE_BOTH_DIR_INFORMATION\nFunction\n: NtQueryDirectoryFile\nFileBasicInformation\nAction\n: Query\nBuffer size\n: 0x28\nStructure\n: FILE_BASIC_INFORMATION\nFunction\n: NtQueryInformationFile\nAction\n: Set\nBuffer size\n: 0x28\nStructure\n: FILE_BASIC_INFORMATION\nFunction\n: NtSetInformationFile\nFileStandardInformation\nAction\n: Query\nBuffer size\n: 0x18\nStructure\n: FILE_STANDARD_INFORMATION\nFunction\n: NtQueryInformationFile\nFileInternalInformation\nAction\n: Query\nBuffer size\n: 0x08\nStructure\n: FILE_INTERNAL_INFORMATION\nFunction\n: NtQueryInformationFile\nFileEaInformation\nAction\n: Query\nBuffer size\n: 0x04\nStructure\n: FILE_EA_INFORMATION\nFunction\n: NtQueryInformationFile\nFileAccessInformation // 8\nFILE_ACCESS_INFORMATION 0x04 NtQueryInformationFile \nFileNameInformation\nAction\n: Query\nBuffer size\n: 0x08+\nStructure\n: FILE_NAME_INFORMATION\nFunction\n: NtQueryInformationFile\nFileRenameInformation\nAction\n: Set\nBuffer size\n: 0x10\nStructure\n: FILE_RENAME_INFORMATION\nFunction\n: NtSetInformationFile\nFileLinkInformation\nAction\n: Set\nBuffer size\n: 0x10\nStructure\n: FILE_LINK_INFORMATION\nFunction\n: NtSetInformationFile\nFileNamesInformation\nAction\n: Query\nBuffer size\n: 0x10\nStructure\n: FILE_NAMES_INFORMATION\nFunction\n: NtQueryDirectoryFile\nFileDispositionInformation\nAction\n: Set\nBuffer size\n: 0x01\nStructure\n: FILE_DISPOSITION_INFORMATION\nFunction\n: NtSetInformationFile\nFilePositionInformation\nAction\n: Query\nBuffer size\n: 0x08\nStructure\n: FILE_POSITION_INFORMATION\nFunction\n: NtQueryInformationFile\nAction\n: Set\nBuffer size\n: 0x08\nStructure\n: FILE_POSITION_INFORMATION\nFunction\n: NtSetInformationFile\nFileFullEaInformation // 15\nFILE_FULL_EA_INFORMATION ??? ??? \nFileModeInformation // 16\nFILE_MODE_INFORMATION 0x04 0x04 NtQueryInformationFile \nFileAlignmentInformation // 17\nFILE_ALIGNMENT_INFORMATION 0x04 NtQueryInformationFile \nFileAllInformation\nAction\n: Query\nBuffer size\n: 0x68\nStructure\n: FILE_ALL_INFORMATION\nFunction\n: NtQueryInformationFile\nFileAllocationInformation // 19\nFILE_ALLOCATION_INFORMATION 0x08 \nFileEndOfFileInformation\nAction\n: Set\nBuffer size\n: 0x08\nStructure\n: FILE_END_OF_FILE_INFORMATION\nFunction\n: NtSetInformationFile\nFileAlternateNameInformation\nAction\n: Query\nBuffer size\n: 0x08+\nStructure\n: FILE_NAME_INFORMATION\nFunction\n: NtQueryInformationFile\nFileStreamInformation // 22\nFILE_STREAM_INFORMATION 0x20 NtQueryInformationFile \nFilePipeInformation // 23\nFILE_PIPE_INFORMATION 0x08 0x08 NtQueryInformationFile \nFilePipeLocalInformation // 24\nFILE_PIPE_LOCAL_INFORMATION 0x28 NtQueryInformationFile \nFilePipeRemoteInformation // 25\nFILE_PIPE_REMOTE_INFORMATION 0x10 0x10 NtQueryInformationFile\nFileMailslotQueryInformation // 26\nFILE_MAILSLOT_QUERY_INFORMATION 0x18 NtQueryInformationFile\nFileMailslotSetInformation // 27\nFILE_MAILSLOT_SET_INFORMATION 0x04 \nFileCompressionInformation // 28\nFILE_COMPRESSION_INFORMATION 0x10 NtQueryInformationFile \nFileCopyOnWriteInformation // 29\nFILE_COPY_ON_WRITE_INFORMATION 0x10 \nFileCompletionInformation\nAction\n: Set\nBuffer size\n: 0x08\nStructure\n: FILE_COMPLETION_INFORMATION\nFunction\n: NtSetInformationFile\nFileMoveClusterInformation // 31 0x10\nFileQuotaInformation // 32\nFILE_QUOTA_INFORMATION 0x10 -&gt; FileOleClassIdInformation\nFileReparsePointInformation // 33 0x08\n-&gt; FileOleStateBitsInformation \nFileNetworkOpenInformation\nAction\n: Query\nBuffer size\n: 0x38\nStructure\n: FILE_NETWORK_OPEN_INFORMATION\nFunction\n: NtQueryInformationFile\nFileObjectIdInformation // 35\nFILE_ATTRIBUTE_TAG_INFORMATION 0x14 \nFileTrackingInformation // 36 0xC0\nNtQueryInformationFile -&gt; FileOleAllInformation \nFileOleDirectoryInformation // 37 0x60\nNtQueryDirectoryFile \nFileContentIndexInformation // 38 0x01\nFileInheritContentIndexInformation //\n39 0x01 \nFileOleInformation // 40 0x38 0x38\nNtQueryInformationFile \nFileMaximumInformation // 41\n\nDocumented by:\nTomasz Nowak\nBo Branten\nSysInternals\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtQueryDirectoryFile\nNtQueryInformationFile\nNtQueryOleDirectoryFile\nNtSetInformationFile\n"
      },
      "FILE_DIRECTORY_INFORMATION": {
            "code": "\ntypedef struct _FILE_DIRECTORY_INFORMATION {\n  ULONG                   NextEntryOffset;\n  ULONG                   FileIndex;\n  LARGE_INTEGER           CreationTime;\n  LARGE_INTEGER           LastAccessTime;\n  LARGE_INTEGER           LastWriteTime;\n  LARGE_INTEGER           ChangeTime;\n  LARGE_INTEGER           EndOfFile;\n  LARGE_INTEGER           AllocationSize;\n  ULONG                   FileAttributes;\n  ULONG                   FileNameLength;\n  WCHAR                   FileName[1];\n} FILE_DIRECTORY_INFORMATION, *PFILE_DIRECTORY_INFORMATION;\n",
            "description": "\nStructure FILE_DIRECTORY_INFORMATION is returned as a\nresult of call \nNtQueryDirectoryFile with \nFileDirectoryInformation information class. It contains some\ntypical informations about directory entries.\nNextEntryOffset Offset (in bytes) of\nnext FILE_DIRECTORY_INFORMATION structure placed in\nresult buffer. If there's no more entries, NextEntryOffset is set to zero.\nFileIndex File index value, or zero, if\ndirectory indexing is not avaiable.\nCreationTime Time of object\ncreation;\nLastAccessTime Last access time. Means\ntime when last open operation was performed.\nLastWriteTime Time of last write\ndata.\nChangeTime Time of last change.\nEndOfFile Specify length of file, in\nbytes.\nAllocationSize Specify real size of\nfile on device. It must be equal or greater to EndOfFile member.\nFileAttributes Attributes of file.\nFileNameLength Length of FileName array, in bytes.\nFileName[1] UNICODE string specifing\nfile name.\n\nDocumented by:\nTomasz Nowak\nBo Branten\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nFILE_BOTH_DIR_INFORMATION\nFILE_FULL_DIR_INFORMATION\nFILE_INFORMATION_CLASS\nFILE_NAMES_INFORMATION\nNtQueryDirectoryFile\n"
      },
      "NtOpenFile": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtOpenFile(\n  OUT PHANDLE             FileHandle,\n  IN ACCESS_MASK          DesiredAccess,\n  IN POBJECT_ATTRIBUTES   ObjectAttributes,\n  OUT PIO_STATUS_BLOCK    IoStatusBlock,\n  IN ULONG                ShareAccess,\n  IN ULONG                OpenOptions );\n",
            "description": "\n(Also avaiable in 2000 DDK.)\nFileHandle Result of call.\nDesiredAccess Access mask to opened\nfile object.\nObjectAttributes File name, path etc.\nSee \nNtCreateFile for more information.\nIoStatusBlock Completion status of\ncall.\nShareAccess Sharing option defined as\nFILE_SHARE_*.\nOpenOptions Open options.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCreateFile\n"
      },
      "NtUnlockFile": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtUnlockFile(\n  IN HANDLE               FileHandle,\n  OUT PIO_STATUS_BLOCK    IoStatusBlock,\n  IN PLARGE_INTEGER       ByteOffset,\n  IN PLARGE_INTEGER       Length,\n  IN PULONG               Key );\n",
            "description": "\nFileHandle HANDLE to File Object\nwith locked region.\nIoStatusBlock IO result of function\ncall.\nByteOffset Offset in file where unlock\nregion begins.\nLength Length of region to unlock.\nKey Pointer to 4-bytes key associated\nwith lock. See \nNtLockFile for additional information about locking by key\nusage.\n\nDocumented by:\nReactos\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCreateFile\nNtLockFile\nNtOpenFile\nNtReadFile\nNtReadFileScatter\nNtWriteFile\nNtWriteFileGather\n"
      },
      "NtQueryEaFile": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtQueryEaFile(\n  IN HANDLE               FileHandle,\n  OUT PIO_STATUS_BLOCK    IoStatusBlock,\n  OUT PVOID               Buffer,\n  IN ULONG                Length,\n  IN BOOLEAN              ReturnSingleEntry,\n  IN PVOID                EaList OPTIONAL,\n  IN ULONG                EaListLength,\n  IN PULONG               EaIndex OPTIONAL,\n  IN BOOLEAN              RestartScan );\n",
            "description": "\nNtQueryEaFile is used to read EA from\nNTFS file. For more information about EA see \nFILE_FULL_EA_INFORMATION.\nFileHandle HANDLE to File Object\nopened with FILE_READ_EA access.\nIoStatusBlock IO result of call.\nBuffer Caller's allocated buffer for\noutput data. See \nFILE_FULL_EA_INFORMATION for detailed description of fields\navaiable in buffer.\nLength Length of buffer, in bytes.\nReturnSingleEntry If set, only one\nentry is returned.\nEaList Optional list of \nFILE_GET_EA_INFORMATION structures containing names of\nEA.\nEaListLength Length of EaList, in bytes.\nEaIndex Pointer to ULONG value\ncontains 1-based index of queried attribute.\nRestartScan If set, result is the first\nquered EA.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nFILE_FULL_EA_INFORMATION\nFILE_GET_EA_INFORMATION\nNtCreateFile\nNtSetEaFile\n"
      },
      "NtFlushBuffersFile": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtFlushBuffersFile(\n  IN HANDLE               FileHandle,\n  OUT PIO_STATUS_BLOCK    IoStatusBlock );\n",
            "description": "\nFunction NtFlushBuffersFile flushes currently cashed\ndata and write it to storage.\nFileHandle HANDLE to File\nObject.\nIoStatusBlock IO result of call.\n\nDocumented by:\nTomasz Nowak\nReactos\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtWriteFile\n"
      },
      "NtCreateNamedPipeFile": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtCreateNamedPipeFile(\n  OUT PHANDLE             NamedPipeFileHandle,\n  IN ACCESS_MASK          DesiredAccess,\n  IN POBJECT_ATTRIBUTES   ObjectAttributes,\n  OUT PIO_STATUS_BLOCK    IoStatusBlock,\n  IN ULONG                ShareAccess,\n  IN ULONG                CreateDisposition,\n  IN ULONG                CreateOptions,\n  IN BOOLEAN              WriteModeMessage,\n  IN BOOLEAN              ReadModeMessage,\n  IN BOOLEAN              NonBlocking,\n  IN ULONG                MaxInstances,\n  IN ULONG                InBufferSize,\n  IN ULONG                OutBufferSize,\n  IN PLARGE_INTEGER       DefaultTimeOut );\n",
            "description": "\nFunction NtCreateNamedPipeFile creates Named\nPipe File Object. Named Pipes are especial kind of files, so\nall functionality is provided with file's functions like \nNtReadFile, \nNtWriteFile etc.\nNamed Pipes are frequently used in NT system, for example as\nstdin and stdout handles.\nNamedPipeFileHandle Result of call -\npointer to HANDLE to Named Pipe.\nDesiredAccess Access rights for\nobject's handle. Can be one or combination of:\nFILE_READ_DATA\nFILE_WRITE_DATA\nFILE_CREATE_PIPE_INSTANCE\nFILE_READ_ATTRIBUTES\nFILE_WRITE_ATTRIBUTES\nSYNCHRONIZE\nREAD_CONTROL\nWRITE_OWNER\nWRITE_DAC\nACCESS_SYSTEM_SECURITY\nAlso combination of Generic rights are supported.\nObjectAttributes Pointer to\nOBJECT_ATTRIBUTES structure contains name of named pipe.\nName must begin with \"\\??\\PIPE\\\" string,\nthat is Symbolic Link to NamedPipe device object.\nIoStatusBlock IO result of call.\nShareAccess Can be combination of\nfollowing:\nFILE_SHARE_READ\nFILE_SHARE_WRITE\nFILE_SHARE_DELETE\nCreateDisposition Use\nFILE_CREATE, FILE_OPEN or FILE_OPEN_IF.\nCreateOptions See description of\nNtCreateFile for possible creation flags.\nWriteModeMessage If set, writing to\ncreated pipe are processed in Message Mode. If not, all\nwrites are in Byte Mode.\nReadModeMessage The same functionality\nas WriteModeMessage parameter,\nbut for reading data.\nNonBlocking If set, all operations on\ncreated pipe are asynchronous.\nMaxInstances Maximum number of open\nhandles for Named Pipe, or FILE_PIPE_UNLIMITED_INSTANCES\nconstant.\nInBufferSize Input buffer size, in\nbytes.\nOutBufferSize Output buffer size, in\nbytes.\nDefaultTimeOut Pointer to\nLARGE_INTEGER value specifing pipe's time out, in\n100-ns units. Negative value means relative time.\n\nDocumented by:\nTomasz Nowak\nReactos\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nFILE_INFORMATION_CLASS\nFILE_PIPE_INFORMATION\nFILE_PIPE_LOCAL_INFORMATION\nFILE_PIPE_REMOTE_INFORMATION\nNtFsControlFile\nNtQueryInformationFile\nNtReadFile\nNtSetInformationFile\nNtWriteFile\n"
      },
      "FILE_NOTIFY_INFORMATION": {
            "code": "\ntypedef struct _FILE_NOTIFY_INFORMATION {\n  ULONG                   NextEntryOffset;\n  ULONG                   Action;\n  ULONG                   FileNameLength;\n  WCHAR                   FileName[1];\n} FILE_NOTIFY_INFORMATION, *PFILE_NOTIFY_INFORMATION;\n",
            "description": "\nFILE_NOTIFY_INFORMATION structure is used in\nprocessing results of call \nNtNotifyChangeDirectoryFile. It is defined in\n&lt;WinNT.h&gt; include file.\nNextEntryOffset Offset to next\nFILE_NOTIFY_INFORMATION structure or zero, if\nlast.\nAction Action indicates notification\npurpose. Can be one of:\nFILE_ACTION_ADDED\nFILE_ACTION_REMOVED\nFILE_ACTION_MODIFIED\nFILE_ACTION_RENAMED_OLD_NAME\nFILE_ACTION_RENAMED_NEW_NAME\nFILE_ACTION_ADDED_STREAM\nFILE_ACTION_REMOVED_STREAM\nFILE_ACTION_MODIFIED_STREAM\nFileNameLength Length of FileName\narray, in bytes.\nFileName[1] Unicode file name.\nOnly some of notification reasons can be readed from Action member. In most cases is contains\nFILE_ACTION_MODIFIED value, and user must check sort of\nnotitication manually.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtNotifyChangeDirectoryFile\n"
      },
      "NtQueryAttributesFile": {
            "code": "\nNTSYSAPI\nNTSTATUS\nNTAPI\nNtQueryAttributesFile(\n  IN POBJECT_ATTRIBUTES   ObjectAttributes,\n  OUT PFILE_BASIC_INFORMATION FileAttributes );\n",
            "description": "\nObjectAttributes Contains file name, in\nNT Objects Namespace format.\nFileAttributes Becouse only four bytes\nat offset 0x20 are used, this may be any buffer at least\n0x24 bytes length. Time information fields from FILE_BASIC_INFORMATION are\nskipped.\nUse of NtQueryAttributesFile is the easiest and the\nbest way to check if file exist. \nNtOpenFile isn't good for this, becouse it modifies last access\ntime for opened file. See NtQueryDirectoryFile for\ndetails.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nFILE_BASIC_INFORMATION\nNtOpenFile\nNtQueryDirectoryFile\nNtQueryFullAttributesFile\nNtQueryInformationFile\n"
      },
      "FILE_FS_ATTRIBUTE_INFORMATION": {
            "code": "\ntypedef struct _FILE_FS_ATTRIBUTE_INFORMATION {\n  ULONG                   FileSystemAttributes;\n  LONG                    MaximumComponentNameLength;\n  ULONG                   FileSystemNameLength;\n  WCHAR                   FileSystemName[1];\n} FILE_FS_ATTRIBUTE_INFORMATION, *PFILE_FS_ATTRIBUTE_INFORMATION;\n",
            "description": "\nFILE_FS_ATTRIBUTE_INFORMATION is output buffer in a\ncall to \nNtQueryVolumeInformationFile function with \nFileFsAttributeInformation information class.\nFileSystemAttributes - ???\n(0x1F)\nMaximumComponentNameLength Maximum\nlength of file name on specified device.\nFileSystemNameLength Length of\nFileSystemName array, in\nbytes.\nFileSystemName[1] Name of File System\non specified device (ex. \"NTFS\").\n\nDocumented by:\nBo Branten\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nFS_INFORMATION_CLASS\nNtQueryVolumeInformationFile\n"
      },
      "NtQueryOleDirectoryFile": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtQueryOleDirectoryFile(\n  IN HANDLE               FileHandle,\n  IN HANDLE               Event OPTIONAL,\n  IN PIO_APC_ROUTINE      ApcRoutine OPTIONAL,\n  IN PVOID                ApcContext OPTIONAL,\n  OUT PIO_STATUS_BLOCK    IoStatusBlock,\n  OUT PVOID               FileInformation,\n  IN ULONG                Length,\n  IN FILE_INFORMATION_CLASS FileInformationClass,\n  IN BOOLEAN              ReturnSingleEntry,\n  IN PUNICODE_STRING      FileMask OPTIONAL,\n  IN BOOLEAN              RestartScan );\n",
            "description": "\nFunction NtQueryOleDirectoryFile is obsolete, and\nit's no longer exported. All OLE functionality is\nimplemented in function \nNtQueryDirectoryFile, also in NT ver. 4.0 .\nAll function's parameters are descripted in \nNtQueryDirectoryFile section.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtQueryDirectoryFile\n"
      },
      "NtLockFile": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtLockFile(\n  IN HANDLE               FileHandle,\n  IN HANDLE               LockGrantedEvent OPTIONAL,\n  IN PIO_APC_ROUTINE      ApcRoutine OPTIONAL,\n  IN PVOID                ApcContext OPTIONAL,\n  OUT PIO_STATUS_BLOCK    IoStatusBlock,\n  IN PLARGE_INTEGER       ByteOffset,\n  IN PLARGE_INTEGER       Length,\n  IN PULONG               Key,\n  IN BOOLEAN              ReturnImmediately,\n  IN BOOLEAN              ExclusiveLock );\n",
            "description": "\nFileHandle HANDLE to File Object\nopened with FILE_READ_DATA access.\nLockGrantedEvent Optional HANDLE\nto Event Object, whitch is signaled when lock is created (typically\nused with ReturnImmediately\nparameter set to TRUE).\nApcRoutine APC routine executed when\nlock is granted.\nApcContext Optional parameter for\nApcRoutine.\nIoStatusBlock IO result of call.\nByteOffset Offset (in bytes) to begin\nof file region to lock.\nLength Length of region to lock, in\nbytes.\nKey Pointer to user's defined 4-bytes\nkey associated with this lock. It can be used in multi-thread\nprocess to allow reading or writing data only for one specified\nthread, whitch known Key\nvalue.\nReturnImmediately If TRUE,\nfunction returns immediately. Caller is informed about lock\ncreation by LockGrantedEvent or\nby executing ApcRoutine.\nExclusiveLock If set, all read and\nwrite operation are denied for other processes. If not, only write\noperation is denied.\n\nDocumented by:\nReactos\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCreateFile\nNtOpenFile\nNtReadFile\nNtReadFileScatter\nNtUnlockFile\nNtWriteFile\nNtWriteFileGather\n"
      },
      "FILE_FULL_DIR_INFORMATION": {
            "code": "\ntypedef struct _FILE_FULL_DIR_INFORMATION {\n  ULONG                   NextEntryOffset;\n  ULONG                   FileIndex;\n  LARGE_INTEGER           CreationTime;\n  LARGE_INTEGER           LastAccessTime;\n  LARGE_INTEGER           LastWriteTime;\n  LARGE_INTEGER           ChangeTime;\n  LARGE_INTEGER           EndOfFile;\n  LARGE_INTEGER           AllocationSize;\n  ULONG                   FileAttributes;\n  ULONG                   FileNameLength;\n  ULONG                   EaSize;\n  WCHAR                   FileName[1];\n} FILE_FULL_DIR_INFORMATION, *PFILE_FULL_DIR_INFORMATION;\n",
            "description": "\nStructure FILE_FULL_DIR_INFORMATION is returned as a\nresult of call \nNtQueryDirectoryFile with \nFileFullDirectoryInformation information class. It contains\nsome typical informations about directory entries, like a FILE_DIRECTORY_INFORMATION\nstructure, but additionally contains member specifing size of\nExtended Attributes.\nNextEntryOffset Offset (in bytes) of\nnext FILE_FULL_DIR_INFORMATION structure placed in\nresult buffer. If there's no more entries, NextEntryOffset is set to zero.\nFileIndex File index value, or zero, if\ndirectory indexing is not avaiable.\nCreationTime Time of object\ncreation;\nLastAccessTime Last access time. Means\ntime when last open operation was performed.\nLastWriteTime Time of last write\ndata.\nChangeTime Time of last change.\nEndOfFile Specify length of file, in\nbytes.\nAllocationSize Specify real size of\nfile on device. It must be equal or greater to EndOfFile member.\nFileAttributes Attributes of file.\nFileNameLength Length of FileName array, in bytes.\nEaSize Size of Extended Attributes\nassociated with file. See also FILE_EA_INFORMATION\nstructure.\nFileName[1] UNICODE string specifing\nfile name.\n\nDocumented by:\nTomasz Nowak\nBo Branten\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nFILE_BOTH_DIR_INFORMATION\nFILE_DIRECTORY_INFORMATION\nFILE_INFORMATION_CLASS\nFILE_NAMES_INFORMATION\nNtQueryDirectoryFile\nNtQueryOleDirectoryFile\n"
      },
      "NtQueryVolumeInformationFile": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtQueryVolumeInformationFile(\n  IN HANDLE               FileHandle,\n  OUT PIO_STATUS_BLOCK    IoStatusBlock,\n  OUT PVOID               FileSystemInformation,\n  IN ULONG                Length,\n  IN FS_INFORMATION_CLASS FileSystemInformationClass );\n",
            "description": "\nFileHandle HANDLE to File\nObject.\nIoStatusBlock IO result of call.\nFileSystemInformation Caller's\nallocated buffer for output data.\nLength Length of FileSystemInformation buffer, in bytes.\nFileSystemInformationClass Information\nclass descripted in \nFS_INFORMATION_CLASS topic.\nNtQueryVolumeInformationFile gives information about\nvolume (device) containing file specified as FileHandle parameter.\n\nDocumented by:\nTomasz Nowak\nBo Branten\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nFS_INFORMATION_CLASS\nNtOpenFile\nNtSetVolumeInformationFile\n"
      },
      "NtWriteFile": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtWriteFile(\n  IN HANDLE               FileHandle,\n  IN HANDLE               Event OPTIONAL,\n  IN PIO_APC_ROUTINE      ApcRoutine OPTIONAL,\n  IN PVOID                ApcContext OPTIONAL,\n  OUT PIO_STATUS_BLOCK    IoStatusBlock,\n  IN PVOID                Buffer,\n  IN ULONG                Length,\n  IN PLARGE_INTEGER       ByteOffset OPTIONAL,\n  IN PULONG               Key OPTIONAL );\n",
            "description": "\n(Also descripted in Win 2000 DDK)\nFileHandle HANDLE to File Object\nopened with FILE_WRITE_DATA access.\nEvent HANDLE to Event Object\nsignaled when write finished.\nApcRoutine User APC routine executed\nafter writing is complete.\nApcContext Parameter to ApcRoutine.\nIoStatusBlock IO result of call.\nBuffer Buffer with data to write.\nLength Length of Buffer, in bytes.\nByteOffset Offset from begining of\nfile, where write starts.\nKey - ??? (See \nNtReadFile).\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCreateFile\nNtOpenFile\nNtReadFile\n"
      },
      "NtCreateMailslotFile": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtCreateMailslotFile(\n  OUT PHANDLE             MailslotFileHandle,\n  IN ACCESS_MASK          DesiredAccess,\n  IN POBJECT_ATTRIBUTES   ObjectAttributes,\n  OUT PIO_STATUS_BLOCK    IoStatusBlock,\n  IN ULONG                CreateOptions,\n  IN ULONG                MailslotQuota,\n  IN ULONG                MaxMessageSize,\n  IN PLARGE_INTEGER       ReadTimeOut );\n",
            "description": "\nFunction NtCreateMailslotFile creates especial File\nObject called Mailslot. See Microsoft SDK for more\ninformation about Mailslots.\nMailslotFileHandle Result of call -\nHANDLE to Mailslot File Object.\nDesiredAccess Access rights associated\nwith opened handle.\nObjectAttributes Pointer to\nOBJECT_ATTRIBUTES structure contains valid object name. Name\nmust be in format \"\\\\??\\MAILSLOT\\...\"\nwhere \"...\" means unique name of\nMailslot.\nIoStatusBlock IO result of call.\nCreateOptions Can be combination\nof:\nFILE_WRITE_THROUGH\nFILE_SYNCHRONOUS_IO_ALERT\nFILE_SYNCHRONOUS_IO_NONALERT\nMailslotQuota - ???\nMaxMessageSize Maximum message size, or\nMAILSLOT_SIZE_AUTO for automatic message size.\nReadTimeOut Timeout value, or -1\nfor infinite waiting.\n\nDocumented by:\nTomasz Nowak\nBo Branten\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nFILE_MAILSLOT_QUERY_INFORMATION\nFILE_MAILSLOT_SET_INFORMATION\nNtQueryInformationFile\nNtReadFile\nNtSetInformationFile\nNtWriteFile\n"
      },
      "NtSetEaFile": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtSetEaFile(\n  IN HANDLE               FileHandle,\n  OUT PIO_STATUS_BLOCK    IoStatusBlock,\n  IN PVOID                EaBuffer,\n  IN ULONG                EaBufferSize );\n",
            "description": "\nSee \nNtQueryEaFile for information about EA.\nFileHandle HANDLE to File Object\nopened with FILE_SET_EA access.\nIoStatusBlock IO result of call.\nEaBuffer User's allocated input buffer\ncontaining one or more FILE_FULL_EA_INFORMATION\nstructures.\nEaBufferSize Size of EaBuffer, in bytes.\n\nDocumented by:\nTomasz Nowak\nBo Branten\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nFILE_FULL_EA_INFORMATION\nNtCreateFile\nNtQueryEaFile\n"
      },
      "FILE_FS_CONTROL_INFORMATION": {
            "code": "\ntypedef struct _FILE_FS_CONTROL_INFORMATION {\n  LARGE_INTEGER           FreeSpaceStartFiltering;\n  LARGE_INTEGER           FreeSpaceThreshold;\n  LARGE_INTEGER           FreeSpaceStopFiltering;\n  LARGE_INTEGER           DefaultQuotaThreshold;\n  LARGE_INTEGER           DefaultQuotaLimit;\n  ULONG                   FileSystemControlFlags;\n} FILE_FS_CONTROL_INFORMATION, *PFILE_FS_CONTROL_INFORMATION;\n",
            "description": "\nStructure FILE_FS_CONTROL_INFORMATION is user as\ninput and output buffers in calls to \nNtQueryVolumeInformationFile and \nNtSetVolumeInformationFile with information class set to\nFileFsControlInformation.\nFreeSpaceStartFiltering \nFreeSpaceThreshold \nFreeSpaceStopFiltering \nDefaultQuotaThreshold \nDefaultQuotaLimit \nFileSystemControlFlags \n\nDocumented by:\nBo Branten\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nFS_INFORMATION_CLASS\nNtQueryVolumeInformationFile\nNtSetVolumeInformationFile\n"
      },
      "FILE_FS_VOLUME_INFORMATION": {
            "code": "\ntypedef struct _FILE_FS_VOLUME_INFORMATION {\n  LARGE_INTEGER           VolumeCreationTime;\n  ULONG                   VolumeSerialNumber;\n  ULONG                   VolumeLabelLength;\n  BOOLEAN                 SupportsObjects;\n  WCHAR                   VolumeLabel[1];\n} FILE_FS_VOLUME_INFORMATION, *PFILE_FS_VOLUME_INFORMATION;\n",
            "description": "\nStructure provides basic information about volume. It's filled in a\nresult of call \nNtQueryVolumeInformationFile with \nFileFsVolumeInformation class.\nVolumeCreationTime It means time of\nlast Volume Formating Process.\nVolumeSerialNumber Serial number of\nvolume, associated in Volume Formating Process.\nVolumeLabelLength Length of\nVolumeLabel array, in\nbytes.\nSupportsObjects If TRUE, Object Files\ncan be stored on specified volume.\nVolumeLabel[1] Name of volume. Can be\nset with \nFileFsLabelInformation.\n\nDocumented by:\nBo Branten\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nFILE_FS_LABEL_INFORMATION\nFS_INFORMATION_CLASS\nNtQueryVolumeInformationFile\n"
      },
      "FILE_FULL_EA_INFORMATION": {
            "code": "\ntypedef struct _FILE_FULL_EA_INFORMATION {\n  ULONG                   NextEntryOffset;\n  BYTE                    Flags;\n  BYTE                    EaNameLength;\n  USHORT                  EaValueLength;\n  CHAR                    EaName[1];\n} FILE_FULL_EA_INFORMATION, *PFILE_FULL_EA_INFORMATION;\n",
            "description": "\nStructure FILE_FULL_EA_INFORMATION is used for get or\nstore Extended Attributes for NTFS files and directories.\nExtended Attributes (EA) is a list of pair\nName-Value. Name is capitalised ASCII string\nup to 256 characters long. Value is any data and can be up\nto 65536 bytes long.\nStructure can be used in a call to \nNtCreateFile and NtSetEaFile, or\nas a result of call NtQueryEaFile.\nNextEntryOffset Offset for next\nFILE_FULL_EA_INFORMATION structure in buffer,\nrelative to currently used structure. If current structure is last\none in buffer, this field has value 0.\nFlags - ???\nEaNameLength Length of EA name, in\nbytes (without leading zero).\nEaValueLength Length of EA value, in\nbytes (without leading zero).\nEaName[1] User's allocated buffer\ncontains ASCIIZ name and value. ASCII value must be finished by\nzero.\nStructure FILE_FULL_EA_INFORMATION is also defined in\nWin2000 DDK.\n\nDocumented by:\nTomasz Nowak\nBo Branten\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nFILE_EA_INFORMATION\nFILE_GET_EA_INFORMATION\nNtCreateFile\nNtQueryEaFile\nNtSetEaFile\n"
      },
      "NtQueryDirectoryFile": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtQueryDirectoryFile(\n  IN HANDLE               FileHandle,\n  IN HANDLE               Event OPTIONAL,\n  IN PIO_APC_ROUTINE      ApcRoutine OPTIONAL,\n  IN PVOID                ApcContext OPTIONAL,\n  OUT PIO_STATUS_BLOCK    IoStatusBlock,\n  OUT PVOID               FileInformation,\n  IN ULONG                Length,\n  IN FILE_INFORMATION_CLASS FileInformationClass,\n  IN BOOLEAN              ReturnSingleEntry,\n  IN PUNICODE_STRING      FileMask OPTIONAL,\n  IN BOOLEAN              RestartScan );\n",
            "description": "\nNtQueryDirectoryFile is used to enumerate entries\n(files or directories) placed into file container object\n(directory). Win32 API use it in\nFindFirstFile-FindNextFile routines.\nFileHandle HANDLE to File Object\nopened with FILE_DIRECTORY_FILE option and\nFILE_LIST_DIRECTORY access.\nEvent Optional HANDLE to Event\nObject signaled after query complete.\nApcRoutine Optinal pointer to user's\nAPC routine queued after query complete.\nApcContext Parameter for ApcRoutine.\nIoStatusBlock Pointer to\nIO_STATUS_BLOCK structure. After enumeration complete,\nInformation member of this structure contains number\nof bytes writed into FileInformation buffer. Status\nmember contains IO result of call, and can be one of:\nSTATUS_SUCCESS - Enumeration has results in FileInformation buffer.\nSTATUS_NO_MORE_FILES - FileInformation buffer is empty, and next\ncall isn't needed.\nSTATUS_NO_SUCH_FILE - Returned when FileMask parameter specify exactly one file\n(don't contains '*' or\n'?' characters), and\nqueried directory don't contains that file.\nFileInformation User's allocated buffer\nfor output data.\nLength Length of FileInformation buffer, in bytes.\nFileInformationClass Information class.\nCan be one of:\nFileDirectoryInformation\nFileFullDirectoryInformation\nFileBothDirectoryInformation\nFileNamesInformation\nFileOleDirectoryInformation\nReturnSingleEntry If set, only one\nentry is returned.\nFileMask If specified, only information\nabout files matches this wildchar mask will be returned.\nWARNING: There's no rule specifing\nwhat to do when caller makes two calls to\nNtQueryDirectoryFile both with different masks.\nTypically FileMask specified in\nsecond call will be ignored, and results will match the first (for\nexample: NTFS.SYS). The best solution is to close\ndirectory HANDLE after every call with FileMask parameter specified.\nRestartScan Used with ReturnSingleEntry parameter. If set,\nNtQueryDirectoryFile continue enumeration after last\nenumerated element in previous call. If no, returns the first entry\nin directory.\nFor detailed information about results, see FILE_INFORMATION_CLASS with\ninformation classes specified above.\n\nDocumented by:\nTomasz Nowak\nBo Branten\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCreateFile\nNtOpenFile\nNtQueryInformationFile\nNtQueryOleDirectoryFile\nNtQueryVolumeInformationFile\n"
      },
      "FILE_FS_SIZE_INFORMATION": {
            "code": "\ntypedef struct _FILE_FS_SIZE_INFORMATION {\n  LARGE_INTEGER           TotalAllocationUnits;\n  LARGE_INTEGER           AvailableAllocationUnits;\n  ULONG                   SectorsPerAllocationUnit;\n  ULONG                   BytesPerSector;\n} FILE_FS_SIZE_INFORMATION, *PFILE_FS_SIZE_INFORMATION;\n",
            "description": "\nStructure provides detailed information about volume physical size.\nIs returned in call to \nNtQueryVolumeInformationFile with \nFileFsSizeInformation information class.\nTotalAllocationUnits \nAvailableAllocationUnits \nSectorsPerAllocationUnit \nBytesPerSector \n\nDocumented by:\nBo Branten\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nFS_INFORMATION_CLASS\nNtQueryVolumeInformationFile\n"
      },
      "NtNotifyChangeDirectoryFile": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtNotifyChangeDirectoryFile(\n  IN HANDLE               FileHandle,\n  IN HANDLE               Event OPTIONAL,\n  IN PIO_APC_ROUTINE      ApcRoutine OPTIONAL,\n  IN PVOID                ApcContext OPTIONAL,\n  OUT PIO_STATUS_BLOCK    IoStatusBlock,\n  OUT PVOID               Buffer,\n  IN ULONG                BufferSize,\n  IN ULONG                CompletionFilter,\n  IN BOOLEAN              WatchTree );\n",
            "description": "\nNtNotifyChangeDirectoryFile is used to process\nchanges to directory File Object. Becouse function returns\nimmediatelly with STATUS_PENDING, you must decide to use\nEvent Object or APC routine as notification form.\nFileHandle HANDLE to File Object\nopened with SYNCHRONIZE access and\nFILE_DIRECTORY_FILE option set.\nEvent HANDLE to Event Object.\nEvent can be created as \nNotificationEvent or \nSynchronizationEvent, but second one is better in this\nsituation.\nApcRoutine Address of user's APC\nroutine, queued when change complete.\nApcContext Optional parameter for\nApcRoutine.\nIoStatusBlock IO result of call.\nStatus member in IoStatusBlock can result\nSTATUS_NOTIFY_ENUM_DIR when Buffer was to small.\nBuffer User's allocated buffer for\nchange informations. It contains one or more of FILE_NOTIFY_INFORMATION\nstructures.\nBufferSize Size of Buffer, in bytes.\nCompletionFilter Mask specifing what\nsort of changes should be monitored. Can be combination\nof:\nFILE_NOTIFY_CHANGE_FILE_NAME\nFILE_NOTIFY_CHANGE_DIR_NAME\nFILE_NOTIFY_CHANGE_NAME\nFILE_NOTIFY_CHANGE_ATTRIBUTES\nFILE_NOTIFY_CHANGE_SIZE\nFILE_NOTIFY_CHANGE_LAST_WRITE\nFILE_NOTIFY_CHANGE_LAST_ACCESS\nFILE_NOTIFY_CHANGE_CREATION\nFILE_NOTIFY_CHANGE_EA\nFILE_NOTIFY_CHANGE_SECURITY\nFILE_NOTIFY_CHANGE_STREAM_NAME\nFILE_NOTIFY_CHANGE_STREAM_SIZE\nFILE_NOTIFY_CHANGE_STREAM_WRITE\nWatchTree If set, all subdirectiories\nof specified directory will be also monitored.\n\nDocumented by:\nTomasz Nowak\nBo Branten\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nEVENT_TYPE\nFILE_NOTIFY_INFORMATION\n"
      },
      "NtCancelIoFile": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtCancelIoFile(\n  IN HANDLE               FileHandle,\n  OUT PIO_STATUS_BLOCK    IoStatusBlock );\n",
            "description": "\nFunction NtCancelIoFile sends cancel signal to Device\nDriver. If any IO operation with specified file is pending, it is\nimmediatelly canceled.\nFileHandle HANDLE to File\nObject.\nIoStatusBlock IO result of call.\n\nDocumented by:\nTomasz Nowak\nReactos\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtFlushBuffersFile\nNtQueryInformationFile\nNtReadFile\nNtSetEaFile\nNtSetInformationFile\nNtWriteFile\n"
      },
      "NtQueryFullAttributesFile": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtQueryFullAttributesFile(\n  IN POBJECT_ATTRIBUTES   ObjectAttributes,\n  OUT PVOID               Attributes );\n",
            "description": "\nFunction NtQueryFullAttributesFile is used to get\ninformation about file stored on low-speed connection device. See\nalso description of \nNtQueryAttributesFile function.\nObjectAttributes Path and name of File\nObject to query.\nAttributes Pointer to \nFILE_NETWORK_OPEN_INFORMATION structure.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nFILE_NETWORK_OPEN_INFORMATION\nNtQueryAttributesFile\n"
      },
      "FILE_NAME_INFORMATION": {
            "code": "\ntypedef struct _FILE_NAME_INFORMATION {\n  ULONG                   FileNameLength;\n  WCHAR                   FileName[1];\n} FILE_NAME_INFORMATION, *PFILE_NAME_INFORMATION;\n",
            "description": "\nStructure FILE_NAME_INFORMATION contains name of\nqueried file object. It's used as a result of call \nNtQueryInformationFile with \nFileNameInformation or \nFileAlternateNameInformation information class.\nFileNameLength Length of FileName, in bytes.\nFileName[1] UNICODE name of file. If\ncaller query about \nFileNameInformation, FileName additionally contains path to file,\nand begins with '\\' (full path to file\nrelative to device).\n\nDocumented by:\nTomasz Nowak\nBo Branten\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nFILE_ALL_INFORMATION\nFILE_INFORMATION_CLASS\nNtQueryInformationFile\n"
      },
      "NtQueryInformationFile": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtQueryInformationFile(\n  IN HANDLE               FileHandle,\n  OUT PIO_STATUS_BLOCK    IoStatusBlock,\n  OUT PVOID               FileInformation,\n  IN ULONG                Length,\n  IN FILE_INFORMATION_CLASS FileInformationClass );\n",
            "description": "\n(Also avaiable in Microsoft 2000 DDK)\nFileHandle HANDLE to File\nObject.\nIoStatusBlock Completion status of\ncall.\nFileInformation Caller's allocated\nbuffer for result data.\nLength Length of FileInformation buffer, in bytes.\nFileInformationClass Enumerated\ninformation class. See FILE_INFORMATION_CLASS for\ndetailed information about usage. \n\nDocumented by:\nTomasz Nowak\nBo Branten\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nFILE_INFORMATION_CLASS\nNtCreateFile\nNtOpenFile\nNtQueryAttributesFile\nNtQueryDirectoryFile\nNtSetInformationFile\n"
      },
      "FILE_BASIC_INFORMATION": {
            "code": "\ntypedef struct _FILE_BASIC_INFORMATION {\n  LARGE_INTEGER           CreationTime;\n  LARGE_INTEGER           LastAccessTime;\n  LARGE_INTEGER           LastWriteTime;\n  LARGE_INTEGER           ChangeTime;\n  ULONG                   FileAttributes;\n} FILE_BASIC_INFORMATION, *PFILE_BASIC_INFORMATION;\n",
            "description": "\nStructure FILE_BASIC_INFORMATION is used in a call to\nfunction \nNtSetInformationFile with \nFileBasicInformation information class, and is received in a\ncall to \nNtQueryInformationFile with the same information class. Also\nfunction \nNtQueryAttributesFile uses as a result\nFILE_BASIC_INFORMATION, but it fills only\nFileAttributes field. See\nrequired function's description for details.\nCreationTime Time of file creation, in\n100-ns units.\nLastAccessTime Time of last open\noperation, in 100-ns units.\nLastWriteTime Time of last write\noperation, in 100-ns units.\nChangeTime Time of any last change, in\n100-ns units.\nFileAttributes File attributes. See\nNtCreateFile for possibilities.\nStructure is also avaiable in Microsoft DDK.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nFILE_INFORMATION_CLASS\nNtCreateFile\nNtQueryAttributesFile\nNtQueryInformationFile\nNtSetInformationFile\n"
      },
      "FILE_NETWORK_OPEN_INFORMATION": {
            "code": "\ntypedef struct _FILE_NETWORK_OPEN_INFORMATION {\n  LARGE_INTEGER           CreationTime;\n  LARGE_INTEGER           LastAccessTime;\n  LARGE_INTEGER           LastWriteTime;\n  LARGE_INTEGER           ChangeTime;\n  LARGE_INTEGER           AllocationSize;\n  LARGE_INTEGER           EndOfFile;\n  ULONG                   FileAttributes;\n  ULONG                   Unknown;\n} FILE_NETWORK_OPEN_INFORMATION, *PFILE_NETWORK_OPEN_INFORMATION;\n",
            "description": "\nFILE_NETWORK_OPEN_INFORMATION structure is used with\ntwo file functions:\n1) \nNtQueryFullAttributesFile,\n2) \nNtQueryInformationFile with \nFileNetworkOpenInformation information class.\nCreationTime Indicates time of file\ncreation.\nLastAccessTime Time of last open\nfile.\nLastWriteTime Time of last write\noperation.\nChangeTime Time of any last\nchange.\nAllocationSize Number of bytes that\nfile use on storage, equal or greater to EndOfFile.\nEndOfFile Length of file, in\nbytes.\nFileAttributes File attributes.\nUnknown - ???\n\nDocumented by:\nTomasz Nowak\nBo Branten\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nFILE_BASIC_INFORMATION\nFILE_INFORMATION_CLASS\nFILE_STANDARD_INFORMATION\nNtCreateFile\nNtOpenFile\nNtQueryAttributesFile\nNtQueryFullAttributesFile\nNtQueryInformationFile\nNtWriteFile\n"
      },
      "FILE_FS_DEVICE_INFORMATION": {
            "code": "\ntypedef struct _FILE_FS_DEVICE_INFORMATION {\n  DEVICE_TYPE             DeviceType;\n  ULONG                   Characteristics;\n} FILE_FS_DEVICE_INFORMATION, *PFILE_FS_DEVICE_INFORMATION;\n",
            "description": "\nFILE_FS_DEVICE_INFORMATION represents output buffer\nin a call to \nNtQueryVolumeInformationFile with \nFileFsDeviceInformation information class. Structure is\navaiable in &lt;ntddk.h&gt; header file from\nWin2000 DDK.\nDeviceType Numeric device types are\ndefined in &lt;ntddk.h&gt; as FILE_DEVICE_*\nprecompiler definitions.\nCharacteristics Or-ed bit mask of\ndevice characteristic. Can be one of:\nFILE_REMOVABLE_MEDIA\nFILE_READ_ONLY_DEVICE\nFILE_FLOPPY_DISKETTE\nFILE_WRITE_ONCE_MEDIA\nFILE_REMOTE_DEVICE\nFILE_DEVICE_IS_MOUNTED\nFILE_VIRTUAL_VOLUME\nFILE_AUTOGENERATED_DEVICE_NAME\nFILE_DEVICE_SECURE_OPEN\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nFS_INFORMATION_CLASS\nNtQueryVolumeInformationFile\n"
      },
      "NtWriteFileGather": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtWriteFileGather(\n  IN HANDLE               FileHandle,\n  IN HANDLE               Event OPTIONAL,\n  IN PIO_APC_ROUTINE      ApcRoutine OPTIONAL,\n  IN PVOID                ApcContext OPTIONAL,\n  OUT PIO_STATUS_BLOCK    IoStatusBlock,\n  IN FILE_SEGMENT_ELEMENT SegmentArray,\n  IN ULONG                Length,\n  IN PLARGE_INTEGER       ByteOffset,\n  IN PULONG               Key OPTIONAL );\n",
            "description": "\nFunction NtWriteFileGather writes specified block of\nfile with data from memory pages. See \nNtReadFileScatter for more information.\nFileHandle HANDLE to File Object\nopened with FILE_WRITE_DATA access and\nFILE_NO_INTERMEDIATE_BUFFERING open option.\nWarring: You\ncannot use File Object opened with FILE_APPEND_DATA\naccess.\nEvent HANDLE to Event Object\nsignaled when writing will finish. Function always use asynchronous\nwriting operation, so caller should define Event or ApcRoutine parameter.\nApcRoutine Pointer to user's APC\nRoutine.\nApcContext Parameter for ApcRoutine.\nIoStatusBlock IO result of call.\nSegmentArray Array of\nFILE_SEGMENT_ELEMENT elements pointing to memory pages to\nwrite. Last array element must be NULL.\nLength Number of bytes to write.\nByteOffset Pointer to\nLARGE_INTEGER value indicates starting position for\nwrite.\nKey Pointer to user's defined key, used\nwhen file is locked (see \nNtLockFile).\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCreateFile\nNtLockFile\nNtOpenFile\nNtReadFileScatter\nNtWriteFile\n"
      },
      "FS_INFORMATION_CLASS": {
            "code": "\ntypedef enum _FS_INFORMATION_CLASS {\n    FileFsVolumeInformation=1,\n    FileFsLabelInformation,\n    FileFsSizeInformation,\n    FileFsDeviceInformation,\n    FileFsAttributeInformation,\n    FileFsControlInformation,\n    FileFsFullSizeInformation,\n    FileFsObjectIdInformation,\n    FileFsMaximumInformation\n} FS_INFORMATION_CLASS, *PFS_INFORMATION_CLASS;\n",
            "description": "\nFS_INFORMATION_CLASS enumeration type is used in a\ncall to NtQueryVolumeInformationFile\nand NtSetVolumeInformationFile.\nFileFsVolumeInformation\nAction\n: Query\nBuffer size\n: 0x18\nStructure\n: FILE_FS_VOLUME_INFORMATION\nFileFsLabelInformation\nAction\n: Set\nBuffer size\n: 0x08\nStructure\n: FILE_FS_LABEL_INFORMATION\nFileFsSizeInformation\nAction\n: Query\nBuffer size\n: 0x18\nStructure\n: FILE_FS_SIZE_INFORMATION\nFileFsDeviceInformation\nAction\n: Query\nBuffer size\n: 0x08\nStructure\n: FILE_FS_DEVICE_INFORMATION\nFileFsAttributeInformation\nAction\n: Query\nBuffer size\n: 0x10\nStructure\n: FILE_FS_ATTRIBUTE_INFORMATION\nFileFsControlInformation\nAction\n: Query, Set\nBuffer size\n: 0x30, 0x30\nStructure\n: FILE_FS_CONTROL_INFORMATION\nFileFsFullSizeInformation\nAction\n: Query\nBuffer size\n: 0x38\nStructure\n: ???\nFileFsObjectIdInformation\nAction\n: Set\nBuffer size\n: 0x38\nStructure\n: ???\n\nDocumented by:\nTomasz Nowak\nBo Branten\nReactos\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nFILE_FS_ATTRIBUTE_INFORMATION\nFILE_FS_CONTROL_INFORMATION\nFILE_FS_DEVICE_INFORMATION\nFILE_FS_LABEL_INFORMATION\nFILE_FS_SIZE_INFORMATION\nFILE_FS_VOLUME_INFORMATION\nNtQueryVolumeInformationFile\nNtSetVolumeInformationFile\n"
      },
      "NtFsControlFile": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtFsControlFile(\n  IN HANDLE               FileHandle,\n  IN HANDLE               Event OPTIONAL,\n  IN PIO_APC_ROUTINE      ApcRoutine OPTIONAL,\n  IN PVOID                ApcContext OPTIONAL,\n  OUT PIO_STATUS_BLOCK    IoStatusBlock,\n  IN ULONG                FsControlCode,\n  IN PVOID                InputBuffer OPTIONAL,\n  IN ULONG                InputBufferLength,\n  OUT PVOID               OutputBuffer OPTIONAL,\n  IN ULONG                OutputBufferLength );\n",
            "description": "\nFunction NtFsControlFile sends FSCTL_* code to\nFile System Device Driver. See also description of \nNtDeviceIoControlFile function.\nFileHandle HANDLE to File System\nDevice Object opened as a file.\nEvent Optional HANDLE to Event\nObject.\nApcRoutine Optional pointer to user's\nAPC Routine.\nApcContext Parameter for ApcRoutine.\nIoStatusBlock IO result of call.\nFsControlCode Control Code typically\ndefined as FSCTL_*.\nInputBuffer User's allocated buffer\ncontains input data.\nInputBufferLength Length of\nInputBuffer, in bytes.\nOutputBuffer User's allocated buffer\nfor results of call.\nOutputBufferLength Length of\nOutputBuffer, in bytes.\n\nDocumented by:\nTomasz Nowak\nReactos\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCreateFile\nNtDeviceIoControlFile\nNtOpenFile\n"
      },
      "NtSetVolumeInformationFile": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtSetVolumeInformationFile(\n  IN HANDLE               FileHandle,\n  OUT PIO_STATUS_BLOCK    IoStatusBlock,\n  IN PVOID                FileSystemInformation,\n  IN ULONG                Length,\n  IN FS_INFORMATION_CLASS FileSystemInformationClass );\n",
            "description": "\nFileHandle HANDLE to File\nObject.\nIoStatusBlock IO result of call.\nFileSystemInformation Buffer containing\ninformation to set, dependly to FileSystemInformationClass parameter.\nLength Length of FileSystemInformation buffer, in bytes.\nFileSystemInformationClass Class of\ninformation to set. See \nFS_INFORMATION_CLASS for valid information classes.\nNtSetVolumeInformationFile sets information to volume\n(device) containing file specified in FileHandle parameter.\n\nDocumented by:\nTomasz Nowak\nBo Branten\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nFS_INFORMATION_CLASS\nNtQueryVolumeInformationFile\n"
      },
      "FILE_RENAME_INFORMATION": {
            "code": "\ntypedef struct _FILE_RENAME_INFORMATION {\n  BOOLEAN                 ReplaceIfExists;\n  HANDLE                  RootDirectory;\n  ULONG                   FileNameLength;\n  WCHAR                   FileName[1];\n} FILE_RENAME_INFORMATION, *PFILE_RENAME_INFORMATION;\n",
            "description": "\nStructure FILE_RENAME_INFORMATION is used as input\nbuffer for function \nNtSetInformationFile, called with \nFileRenameInformation information class. Using this structure\ncaller can rename file, or move it into other directory.\nReplaceIfExists If set, and file with\nthe same name as destination exist, it will be replaced. If no,\nSTATUS_OBJECT_NAME_COLLISION is returned.\nRootDirectory Optional HANDLE to\nparent directory for destination file.\nFileNameLength Length of FileName array, in bytes.\nFileName[1] UNICODE string specifing\ndestination file name. If RootDirectory is NULL, it must\ncontains full system path, or only destination file name for\nin-place rename operation.\n\nDocumented by:\nTomasz Nowak\nBo Branten\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nFILE_INFORMATION_CLASS\nNtCreateFile\nNtNotifyChangeDirectoryFile\nNtOpenFile\nNtSetInformationFile\n"
      },
      "NtSetInformationFile": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtSetInformationFile(\n  IN HANDLE               FileHandle,\n  OUT PIO_STATUS_BLOCK    IoStatusBlock,\n  IN PVOID                FileInformation,\n  IN ULONG                Length,\n  IN FILE_INFORMATION_CLASS FileInformationClass );\n",
            "description": "\n(Description of this function is also avaiable in Win2000\nDDK)\nFileHandle HANDLE to File\nObject.\nIoStatusBlock IO result of call.\nFileInformation User's allocated buffer\ncontains data to set to.\nLength Length of FileInformation buffer, in bytes.\nFileInformationClass See FILE_INFORMATION_CLASS for\npossible information classes and required contents of FileInformation buffer.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nFILE_INFORMATION_CLASS\nNtOpenFile\nNtQueryInformationFile\nNtSetVolumeInformationFile\n"
      },
      "NtCreatePagingFile": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtCreatePagingFile(\n  IN PUNICODE_STRING      PageFileName,\n  IN PLARGE_INTEGER       MiniumSize,\n  IN PLARGE_INTEGER       MaxiumSize,\n  OUT PLARGE_INTEGER      ActualSize OPTIONAL );\n",
            "description": "\nFunction NtCreatePagingFile is typically used by\nControl Panel's \"System\" applet for creating new paged\nfiles.\nPageFileName System path to newly\ncreated paged file.\nMiniumSize Minimum size of paged file,\nin bytes. This value must be multiply of page size (0x1000\nbytes on x86), and must be greater then 2MB\n(0x02000000 bytes).\nMaxiumSize Maximum size of paged file,\nin bytes. Also this value must be multiply of page size. Minimal\nvalue accepted is 5MB (0x05000000 bytes).\nActualSize Optional (and currently\nunused) parameter.\n\nDocumented by:\nTomasz Nowak\nReactos\nRequirements:\n\nLibrary: ntdll.lib\nPrivilege: SE_CREATE_PAGEFILE_PRIVILEGE\n\nSee also:\nSYSTEM_PAGEFILE_INFORMATION\n"
      },
      "NtReadFile": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtReadFile(\n  IN HANDLE               FileHandle,\n  IN HANDLE               Event OPTIONAL,\n  IN PIO_APC_ROUTINE      ApcRoutine OPTIONAL,\n  IN PVOID                ApcContext OPTIONAL,\n  OUT PIO_STATUS_BLOCK    IoStatusBlock,\n  OUT PVOID               Buffer,\n  IN ULONG                Length,\n  IN PLARGE_INTEGER       ByteOffset OPTIONAL,\n  IN PULONG               Key OPTIONAL );\n",
            "description": "\n(Also descripted in Win2000 DDK)\nFileHandle HANDLE to File Object\nopened with FILE_READ_DATA access.\nEvent Optional HANDLE to Event\nObject signaled when reading is done.\nApcRoutine User defined APC\nroutine queued for execute after reading is done.\nApcContext User parameter to\nApcRoutine.\nIoStatusBlock Pointer to IO_STATUS\nstructure received IO status of file reading.\nBuffer User-allocated buffer for readed\ndata.\nLength Length of Buffer, in bytes.\nByteOffset Offset from begining of\nfile, in bytes.\nKey - ??? (In my opinion: use this, if\nyou previously lock file, and now you want read it, but without\nunlocking).\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCreateFile\nNtOpenFile\nNtWriteFile\n"
      },
      "NtReadFileScatter": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtReadFileScatter(\n  IN HANDLE               FileHandle,\n  IN HANDLE               Event OPTIONAL,\n  IN PIO_APC_ROUTINE      ApcRoutine OPTIONAL,\n  IN PVOID                ApcContext OPTIONAL,\n  OUT PIO_STATUS_BLOCK    IoStatusBlock,\n  IN FILE_SEGMENT_ELEMENT SegmentArray,\n  IN ULONG                Length,\n  IN PLARGE_INTEGER       ByteOffset,\n  IN PULONG               Key OPTIONAL );\n",
            "description": "\nFunction NtReadFileScatter reads specified block from\nfile into multiple buffers. Each buffer must have one page length\n(0x1000 bytes on x86).\nFileHandle HANDLE to File Object\nopened with FILE_READ_DATA access and with\nFILE_NO_INTERMEDIATE_BUFFERING open option.\nEvent HANDLE to Event Object\nsignaled when reading is complete. This parameter is optional, but\ncaller should use one of notification way, becouse function always\nuse asynchronous reading method.\nApcRoutine Optional pointer to user's\nAPC Routine.\nApcContext User's parameter for\nApcRoutine.\nIoStatusBlock IO result of call.\nSegmentArray Array of\nFILE_SEGMENT_ELEMENT unions. Any element point to allocated\nmemory page address. Last element of array must be\nNULL.\nLength Number of bytes to read.\nByteOffset Pointer to\nLARGE_INTEGER value indicates reading start position.\nKey Optional pointer to user's key,\nused when file is locked (see \nNtLockFile).\nSee also ReadFileScatter description in Microsoft\nSDK.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCreateFile\nNtLockFile\nNtOpenFile\nNtReadFile\nNtUnlockFile\nNtWriteFileGather\n"
      },
      "FILE_LINK_INFORMATION": {
            "code": "\ntypedef struct _FILE_LINK_INFORMATION {\n  BOOLEAN                 ReplaceIfExists;\n  HANDLE                  RootDirectory;\n  ULONG                   FileNameLength;\n  WCHAR                   FileName[1];\n} FILE_LINK_INFORMATION, *PFILE_LINK_INFORMATION;\n",
            "description": "\nStructure FILE_LINK_INFORMATION is used as input\nbuffer for function \nNtSetInformationFile called with \nFileLinkInformation information class for make hard link to\nfile.\nOn standart NT system only links to files are accepted.\nCaller cannot create link to directory (for Poxis\ncompatibility reason).\nReplaceIfExists If set, and destination\nobject already exists, it will be replaced with newly created\nlink.\nRootDirectory HANDLE to File\nObject specyfing directory where link should be placed. Can be\nNULL if FileName\nparameter contains full path.\nFileNameLength Length of FileName array, in bytes.\nFileName[1] UNICODE string specyfing\nname of link and optionally with path (see description of\nRootDirectory).\n\nDocumented by:\nTomasz Nowak\nBo Branten\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nFILE_INFORMATION_CLASS\nFILE_RENAME_INFORMATION\nNtSetInformationFile\n"
      },
      "NtWaitForKeyedEvent": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtWaitForKeyedEvent(\n  IN HANDLE               KeyedEventHandle,\n  IN PVOID                Key,\n  IN BOOLEAN              Alertable,\n  IN PLARGE_INTEGER       Timeout OPTIONAL );\n",
            "description": "\nFunction with similar functionality as \nNtReleaseKeyedEvent. In my opinion it is not needed and exists\nonly for future vision of KeyedEvent objects or just\nas a mistake.\nKeyedEventHandle HANDLE for\npreviously opened KeyedEvent object.\nKey Value to wait for, must have lowest\nbit clear.\nAlertable If set, waiting can be broken\nby alerting thread.\nTimeout Optinally pointer for timing\nout value.\nSupported on system versions:\nWin XP/2003\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCreateKeyedEvent\nNtOpenKeyedEvent\nNtReleaseKeyedEvent\n"
      },
      "NtReleaseKeyedEvent": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtReleaseKeyedEvent(\n  IN HANDLE               KeyedEventHandle,\n  IN PVOID                Key,\n  IN BOOLEAN              Alertable,\n  IN PLARGE_INTEGER       Timeout OPTIONAL );\n",
            "description": "\nThis function is used for signal KeyedEvent object\nwith value specified as Key\nparameter. If there are no other thread (or threads) waiting for\nthe same KeyedEvent with the same Key value, waiting is performed up to\nNtWaitForKeyedEvent called by any other thread.\nKeyedEventHandle HANDLE to\nKeyedEvent object.\nKey Value used as KEY. Note that\nthis value has to have lowest bit cleared (must divide by\ntwo).\nAlertable If set, waiting can be broken\nby alerting thread.\nTimeout Optional pointer for timeout\nvalue.\nSupported on system versions:\nWin XP/2003\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCreateKeyedEvent\nNtOpenKeyedEvent\nNtWaitForKeyedEvent\n"
      },
      "NtOpenKeyedEvent": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtOpenKeyedEvent(\n  OUT PHANDLE             KeyedEventHandle,\n  IN ACCESS_MASK          DesiredAccess,\n  IN POBJECT_ATTRIBUTES   ObjectAttributes OPTIONAL );\n",
            "description": "\nFunction NtOpenKeyedEvent is used for open previously\ncreated KeyedEvent with associated name.\nKeyedEventHandle Result of call -\nHANDLE to opened KeyedEvent object.\nDesiredAccess Access to object, the\nsame values as for Event object.\nObjectAttributes Name of\nKeyedEvent to open.\nSupported on system versions:\nWin XP/2003\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCreateKeyedEvent\n"
      },
      "NtCreateKeyedEvent": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtCreateKeyedEvent(\n  OUT PHANDLE             KeyedEventHandle,\n  IN ACCESS_MASK          DesiredAccess,\n  IN POBJECT_ATTRIBUTES   ObjectAttributes OPTIONAL,\n  IN ULONG                Reserved );\n",
            "description": "\nSynchronization object called KeyedEvent is avaiable\nin Windows XP+ systems. It's usefull when both (or more)\nthreads have to wait for each other.\nKeyedEventHandle HANDLE to newly\ncreated KeyedEvent object.\nDesiredAccess The same values as for\nEvent objects (typically\nEVENT_ALL_ACCESS).\nObjectAttributes Optionally name of\nobject.\nReserved Have to be zero. Reserved for\nfuture use.\nSupported on system versions:\nWin XP/2003\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtOpenKeyedEvent\nNtReleaseKeyedEvent\nNtWaitForkeyedEvent\n"
      },
      "TIMER_INFORMATION_CLASS": {
            "code": "\ntypedef enum _TIMER_INFORMATION_CLASS {\n    TimerBasicInformation\n} TIMER_INFORMATION_CLASS, *PTIMER_INFORMATION_CLASS;\n",
            "description": "\nCurrently only one information class is avaiable for Timer Object.\nTimerBasicInformation Information\nbuffer is TIMER_BASIC_INFORMATION\nstructure.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtQueryTimer\nTIMER_BASIC_INFORMATION\n"
      },
      "NtSetTimer": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtSetTimer(\n  IN HANDLE               TimerHandle,\n  IN PLARGE_INTEGER       DueTime,\n  IN PTIMER_APC_ROUTINE   TimerApcRoutine OPTIONAL,\n  IN PVOID                TimerContext OPTIONAL,\n  IN BOOLEAN              ResumeTimer,\n  IN LONG                 Period OPTIONAL,\n  OUT PBOOLEAN            PreviousState OPTIONAL );\n",
            "description": "\nTimerHandle HANDLE to Timer\nObject opened with TIMER_MODIFY_STATE access.\nDueTime Time when timer should be set,\nin 100ns units. If it is negative value, it means relative\ntime.\nTimerApcRoutine User's APC routine,\ndefined as follows:\n        typedef void (*PTIMER_APC_ROUTINE)(\n                        IN PVOID TimerContext,\n                        IN ULONG TimerLowValue,\n                        IN LONG TimerHighValue\n                        );\n"
      },
      "NtCreateTimer": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtCreateTimer(\n  OUT PHANDLE             TimerHandle,\n  IN ACCESS_MASK          DesiredAccess,\n  IN POBJECT_ATTRIBUTES   ObjectAttributes OPTIONAL,\n  IN TIMER_TYPE           TimerType );\n",
            "description": "\nTimerHandle Result of call -\nHANDLE to Timer Object.\nDesiredAccess Access mask for\nTimerHandle. Can be set of (from\n&lt;WinNT.h&gt;):\nTIMER_QUERY_STATE\nTIMER_MODIFY_STATE\nTIMER_ALL_ACCESS\nObjectAttributes Optional name of Timer\nObject.\nTimerType Can be\nNotificationTimer or\nSynchronizationTimer (enumerated type definition from\n&lt;ntdef.h&gt;). See also \nEVENT_TYPE.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nEVENT_TYPE\nNtOpenTimer\n"
      },
      "NtQueryTimer": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtQueryTimer(\n  IN HANDLE               TimerHandle,\n  IN TIMER_INFORMATION_CLASS TimerInformationClass,\n  OUT PVOID               TimerInformation,\n  IN ULONG                TimerInformationLength,\n  OUT PULONG              ReturnLength OPTIONAL );\n",
            "description": "\nTimerHandle HANDLE to Timer\nObject opened with TIMER_QUERY_STATE access.\nTimerInformationClass Information\nclass. See TIMER_INFORMATION_CLASS for\ndetails.\nTimerInformation User's allocated\nbuffer for result data.\nTimerInformationLength Length of\nTimerInformation buffer, in\nbytes.\nReturnLength Optional pointer to value\nreceived used/required length of TimerInformation buffer.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCreateTimer\nNtOpenTimer\nTIMER_INFORMATION_CLASS\n"
      },
      "NtCancelTimer": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtCancelTimer(\n  IN HANDLE               TimerHandle,\n  OUT PBOOLEAN            CurrentState OPTIONAL );\n",
            "description": "\nTimerHandle HANDLE to Timer\nObject opened with TIMER_MODIFY_STATE access.\nCurrentState Pointer to BOOLEAN\nvalue, that received state of timer before function call.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtOpenTimer\nNtQueryTimer\nNtSetTimer\n"
      },
      "TIMER_BASIC_INFORMATION": {
            "code": "\ntypedef struct _TIMER_BASIC_INFORMATION {\n  LARGE_INTEGER           RemainingTime;\n  BOOLEAN                 TimerState;\n} TIMER_BASIC_INFORMATION, *PTIMER_BASIC_INFORMATION;\n",
            "description": "\nRemainingTime Contains time (in 100ns\nunits) to next timer signal (negative value), or time after last\nsignalization.\nTimerState If TRUE, timer is\nsignaled.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtQueryTimer\nTIMER_INFORMATION_CLASS\n"
      },
      "NtOpenTimer": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtOpenTimer(\n  OUT PHANDLE             TimerHandle,\n  IN ACCESS_MASK          DesiredAccess,\n  IN POBJECT_ATTRIBUTES   ObjectAttributes );\n",
            "description": "\nTimerHandle Result of call -\nHANDLE to Timer Object.\nDesiredAccess Access mask for\nTimerHandle. See NtCreateTimer for possible values.\nObjectAttributes Name of Timer\nObject.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCreateTimer\n"
      },
      "RtlFormatCurrentUserKeyPath": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nRtlFormatCurrentUserKeyPath(\n  OUT PUNICODE_STRING  RegistryPath );\n",
            "description": "\n"
      },
      "NtLoadKey2": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtLoadKey2(\n  IN POBJECT_ATTRIBUTES   DestinationKeyName,\n  IN POBJECT_ATTRIBUTES   HiveFileName,\n  IN ULONG                Flags );\n",
            "description": "\nFunction NtLoadKey2 loads Hive file into registry\nstructure.\nDestinationKeyName Pointer to\nOBJECT_ATTRIBUTES structure contains name of loaded key and\nvirtual parent key (\"machine\" or\n\"user\").\nHiveFileName Pointer to\nOBJECT_ATTRIBUTES structure specifing Hive file.\nFlags (?) Only values\n0x0000 and 0x0004 are valid. If caller set\nFlags to 0x0000, function works\nas \nNtLoadKey.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\nPrivilege: SE_RESTORE_PRIVILEGE\n\nSee also:\nNtLoadKey\nNtSaveKey\nNtUnloadKey\n"
      },
      "NtQueryKey": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtQueryKey(\n  IN HANDLE               KeyHandle,\n  IN KEY_INFORMATION_CLASS KeyInformationClass,\n  OUT PVOID               KeyInformation,\n  IN ULONG                Length,\n  OUT PULONG              ResultLength );\n",
            "description": "\nSee ZwQueryKey in NT DDK or 2000 DDK for detailed description.\n"
      },
      "NtCreateKey": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtCreateKey(\n  OUT PHANDLE             pKeyHandle,\n  IN ACCESS_MASK          DesiredAccess,\n  IN POBJECT_ATTRIBUTES   ObjectAttributes,\n  IN ULONG                TitleIndex,\n  IN PUNICODE_STRING      Class OPTIONAL,\n  IN ULONG                CreateOptions,\n  OUT PULONG              Disposition OPTIONAL );\n",
            "description": "\nSee ZwCreateKey in NT DDK or 2000 DDK for detailed description.\n"
      },
      "NtOpenKey": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtOpenKey(\n  OUT PHANDLE             pKeyHandle,\n  IN ACCESS_MASK          DesiredAccess,\n  IN POBJECT_ATTRIBUTES   ObjectAttributes );\n",
            "description": "\nSee ZwOpenKey in NT DDK or 2000 DDK for detailed description.\n"
      },
      "NtEnumerateValueKey": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtEnumerateValueKey(\n  IN HANDLE               KeyHandle,\n  IN ULONG                Index,\n  IN KEY_VALUE_INFORMATION_CLASS KeyValueInformation,\n  OUT PVOID               KeyValueInformation,\n  IN ULONG                Length,\n  OUT PULONG              ResultLength );\n",
            "description": "\nSee ZwEnumerateValueKey in NT DDK or 2000 DDK for detailed description.\n"
      },
      "NtLoadKey": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtLoadKey(\n  IN POBJECT_ATTRIBUTES   DestinationKeyName,\n  IN POBJECT_ATTRIBUTES   HiveFileName );\n",
            "description": "\nFunction NtLoadKey is used to make avaiable registry\nkeys and values stored in Hive File. Hive file can be\ncreated by calling \nNtSaveKey. If loaded Hive is no longer needed (for\nexample when user logout for HKCU Hive), it can be udloaded\nby call \nNtUnloadKey.\nDestinationKeyName Pointer to\nOBJECT_ATTRIBUTES structure contains destination key name\nand HANDLE to root key. Root can be \\REGISTRY\\machine or \\REGISTRY\\user. All other keys are invalid.\nHiveFileName Pointer to\nOBJECT_ATTRIBUTES structure contains Hive file path\nand name.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\nPrivilege: SE_RESTORE_PRIVILEGE\n\nSee also:\nNtLoadKey2\nNtSaveKey\nNtUnloadKey\n"
      },
      "NtQueryValueKey": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtQueryValueKey(\n  IN HANDLE               KeyHandle,\n  IN PUNICODE_STRING      ValueName,\n  IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,\n  OUT PVOID               KeyValueInformation,\n  IN ULONG                Length,\n  OUT PULONG              ResultLength );\n",
            "description": "\nSee ZwQueryValueKey in NT DDK or 2000 DDK for detailed description.\n"
      },
      "NtSetInformationKey": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtSetInformationKey(\n  IN HANDLE               KeyHandle,\n  IN KEY_SET_INFORMATION_CLASS InformationClass,\n  IN PVOID                KeyInformationData,\n  IN ULONG                DataLength );\n",
            "description": "\nInformationClass\n"
      },
      "NtEnumerateKey": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtEnumerateKey(\n  IN HANDLE               KeyHandle,\n  IN ULONG                Index,\n  IN KEY_INFORMATION_CLASS KeyInformationClass,\n  OUT PVOID               KeyInformation,\n  IN ULONG                Length,\n  OUT PULONG              ResultLength );\n",
            "description": "\nSee ZwEnumerateKey in NT DDK or 2000 DDK for detailed description.\n"
      },
      "NtRestoreKey": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtRestoreKey(\n  IN HANDLE               KeyHandle,\n  IN HANDLE               FileHandle,\n  IN ULONG                RestoreOption );\n",
            "description": "\nKeyHandle\n"
      },
      "NtCompactKeys": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtCompactKeys(\n  IN ULONG                NrOfKeys,\n  IN HANDLE               KeysArray[] );\n",
            "description": "\nFunction NtCompactKeys compacts (reduces size) of\nspecified key(s). On Windows NT the same functionality was given by\nuse \nNtSaveKey and \nNtRestoreKey\nNrOfKeys Number of enries in\nKeysArray array.\nKeysArray[] Array containing handles\nfor previously opened keys.\nSupported on system versions:\nWin 2000,Win XP/2003\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCreateKey\nNtOpenKey\nNtRestoreKey\nNtSaveKey\n"
      },
      "NtSaveKey": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtSaveKey(\n  IN HANDLE               KeyHandle,\n  IN HANDLE               FileHandle );\n",
            "description": "\nKeyHandle\n"
      },
      "NtQueryMultipleValueKey": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtQueryMultipleValueKey(\n  IN HANDLE               KeyHandle,\n  IN OUT PKEY_MULTIPLE_VALUE_INFORMATION ValuesList,\n  IN ULONG                NumberOfValues,\n  OUT PVOID               DataBuffer,\n  IN OUT ULONG            BufferLength,\n  OUT PULONG              RequiredLength OPTIONAL );\n",
            "description": "\nFunction NtQueryMultipleValueKey returns data of one\nor more values under specified Key Object.\nKeyHandle HANDLE to Key Object\nopened with KEY_READ access.\nValuesList Array of \nKEY_MULTIPLE_VALUE_INFORMATION structures contains names of\nvalues to query.\nNumberOfValues Number of members in\nValueList array.\nDataBuffer User's allocated buffer\nreceiving queried value's data.\nBufferLength Pointer to value specifing\nlength of DataBuffer, in\nbytes.\nRequiredLength Optionally pointer to\nvalue receiving required DataBuffer length, in bytes.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nKEY_MULTIPLE_VALUE_INFORMATION\nNtCreateKey\nNtEnumerateValueKey\nNtOpenKey\nNtQueryValueKey\n"
      },
      "NtUnloadKey": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtUnloadKey(\n  IN POBJECT_ATTRIBUTES   DestinationKeyName );\n",
            "description": "\nFunction NtUnloadKey unloads previously loaded\nHive file from registry structure. All changes made to keys\nand values under this Hive are stored.\nDestinationKeyName Pointer to\nOBJECT_ATTRIBUTES structure contains path and name of\nHive root key.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\nPrivileges: SE_RESTORE_PRIVILEGE\n\nSee also:\nNtLoadKey\nNtLoadKey2\n"
      },
      "NtDeleteKey": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtDeleteKey(\n  IN HANDLE               KeyHandle );\n",
            "description": "\nSee ZwDeleteKey in NT DDK or 2000 DDK for detailed description.\n"
      },
      "NtDeleteValueKey": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtDeleteValueKey(\n  IN HANDLE               KeyHandle,\n  IN PUNICODE_STRING      ValueName );\n",
            "description": "\n"
      },
      "NtNotifyChangeKey": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtNotifyChangeKey(\n  IN HANDLE               KeyHandle,\n  IN HANDLE               EventHandle,\n  IN PIO_APC_ROUTINE      ApcRoutine,\n  IN PVOID                ApcRoutineContext,\n  IN PIO_STATUS_BLOCK     IoStatusBlock,\n  IN ULONG                NotifyFilter,\n  IN BOOLEAN              WatchSubtree,\n  OUT PVOID               RegChangesDataBuffer,\n  IN ULONG                RegChangesDataBufferLength,\n  IN BOOLEAN              Asynchronous );\n",
            "description": "\n"
      },
      "NtReplaceKey": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtReplaceKey(\n  IN POBJECT_ATTRIBUTES   NewHiveFileName,\n  IN HANDLE               KeyHandle,\n  IN POBJECT_ATTRIBUTES   BackupHiveFileName );\n",
            "description": "\nFunction NtReplaceKey save specified hive key to\nfile, and starts use this file instread of original hive file.\nOriginal hive file contents is replaced with contents of third hive\nfile, specified below.\nNewHiveFileName Pointer to\nOBJECT_ATTRIBUTES structure containing name of third file\n(file with new contents).\nKeyHandle HANDLE to Key Object.\nBackuped and replaced are all keys from hive whith contains key\nspecified by KeyHandle\nparameter.\nBackupHiveFileName Pointer to\nOBJECT_ATTRIBUTES structure containing name of first file\n(new hive file).\nExample:\nNewHiveFile -&gt;\nOrginalHiveFile -&gt; BackupHiveFile\nBefore call to NtReplaceKey system\nuses OriginalHiveFile.\nAfter call, system use BackupHiveFile.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtLoadKey\nNtLoadKey2\nNtRestoreKey\nNtSaveKey\nNtUnloadKey\n"
      },
      "NtCompressKey": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtCompressKey(\n  IN HANDLE               Key );\n",
            "description": "\nThis function compress data associated with specified Key and all his sub-keys. Compressed key\nrequire smaller space in registry file, but whole functionality\nused with compressed key works slower.\nKey HANDLE of previously opened\nkey object (with write access).\nSupported on system versions:\nWin 2000,Win XP/2003\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCompactKeys\nNtCreateKey\nNtOpenKey\n"
      },
      "NtFlushKey": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtFlushKey(\n  IN HANDLE               KeyHandle );\n",
            "description": "\nSee ZwFlushKey in NT DDK or 2000 DDK for detailed description.\n"
      },
      "NtSetValueKey": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtSetValueKey(\n  IN HANDLE               KeyHandle,\n  IN PUNICODE_STRING      ValueName,\n  IN ULONG                TitleIndex OPTIONAL,\n  IN ULONG                Type,\n  IN PVOID                Data,\n  IN ULONG                DataSize );\n",
            "description": "\nSee ZwSetValueKey in NT DDK or 2000 DDK for detailed description.\n"
      },
      "KEY_MULTIPLE_VALUE_INFORMATION": {
            "code": "\ntypedef struct _KEY_MULTIPLE_VALUE_INFORMATION {\n  PUNICODE_STRING         ValueName;\n  ULONG                   DataLength;\n  ULONG                   DataOffset;\n  ULONG                   Type;\n} KEY_MULTIPLE_VALUE_INFORMATION, *PKEY_MULTIPLE_VALUE_INFORMATION;\n",
            "description": "\nStructure KEY_MULTIPLE_VALUE_INFORMATION is used with\nfunction \nNtQueryMultipleValueKey.\nValueName Pointer to\nUNICODE_STRING structure containing value name. If specified\nvalue not exist, function fails.\nDataLength Length of value's data, in\nbytes.\nDataOffset Offset in output buffer\n(declared in \nNtQueryMultipleValueKey) to value's data.\nType Type of queried value.\nOn entry caller must specify ValueName parameter, and set other to\nzero. Function \nNtQueryMultipleValueKey fills rest of fields with informations\nabout specified value.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtQueryMultipleValueKey\n"
      },
      "SEMAPHORE_BASIC_INFORMATION": {
            "code": "\ntypedef struct _SEMAPHORE_BASIC_INFORMATION {\n  ULONG                   CurrentCount;\n  ULONG                   MaximumCount;\n} SEMAPHORE_BASIC_INFORMATION, *PSEMAPHORE_BASIC_INFORMATION;\n",
            "description": "\nStructure SEMAPHORE_BASIC_INFORMATION is retrieved as\na result of call \nNtQuerySemaphore with \nSemaphoreBasicInformation information class.\nCurrentCount Current state of\nsemaphore's counter.\nMaximumCount Maximum counter position,\ndefined with call to \nNtCreateSemaphore.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCreateSemaphore\nNtQuerySemaphore\nSEMAPHORE_INFORMATION_CLASS\n"
      },
      "NtCreateSemaphore": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtCreateSemaphore(\n  OUT PHANDLE             SemaphoreHandle,\n  IN ACCESS_MASK          DesiredAccess,\n  IN POBJECT_ATTRIBUTES   ObjectAttributes OPTIONAL,\n  IN ULONG                InitialCount,\n  IN ULONG                MaximumCount );\n",
            "description": "\nFunction NtCreateSemaphore creates Semaphore Object\nwith or without name in Object Namespace, and sets initial and\nmaximum releases number.\nSemaphoreHandle Result of call -\npointer to HANDLE to Semaphore Object.\nDesiredAccess Access rights to\nSemaphore Object. Can be one of:\nSEMAPHORE_QUERY_STATE\nSEMAPHORE_MODIFY_STATE\nSEMAPHORE_ALL_ACCESS\nObjectAttributes Optional pointer to\nOBJECT_ATTRIBUTES structure containing semaphore's\nname.\nInitialCount Initial state of\nsemaphore. Typically the same as MaximumCount.\nMaximumCount Maximum releases\nnumber.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtOpenSemaphore\nNtQuerySemaphore\n"
      },
      "NtReleaseSemaphore": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtReleaseSemaphore(\n  IN HANDLE               SemaphoreHandle,\n  IN ULONG                ReleaseCount,\n  OUT PULONG              PreviousCount OPTIONAL );\n",
            "description": "\nFunction NtReleaseSemaphore increments semaphore's\ncounter, oposite to any waiting function (semaphore is signaled\nwhen semaphore's counter is greater then zero).\nSemaphoreHandle HANDLE to\nSemaphore Object opened with SEMAPHORE_MODIFY_STATE\naccess.\nReleaseCount Number of increments,\ntypically set to 1.\nPreviousCount Optional pointer to\nULONG value receiving semaphore's counter state before\ncall.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCreateSemaphore\nNtOpenSemaphore\nNtQuerySemaphore\n"
      },
      "NtOpenSemaphore": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtOpenSemaphore(\n  OUT PHANDLE             SemaphoreHandle,\n  IN ACCESS_MASK          DesiredAccess,\n  IN POBJECT_ATTRIBUTES   ObjectAttributes );\n",
            "description": "\nFunction NtOpenSemaphore opens named Semaphore\nObject. This operation doesn't modify semaphore's internal\ncounter.\nSemaphoreHandle Result of call -\npointer to HANDLE to Semaphore Object.\nDesiredAccess Access rights, descripted\nin \nNtCreateSemaphore.\nObjectAttributes Pointer to\nOBJECT_ATTRIBUTES structure containing semaphore's name.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCreateSemaphore\n"
      },
      "SEMAPHORE_INFORMATION_CLASS": {
            "code": "\ntypedef enum _SEMAPHORE_INFORMATION_CLASS {\n    SemaphoreBasicInformation\n} SEMAPHORE_INFORMATION_CLASS, *PSEMAPHORE_INFORMATION_CLASS;\n",
            "description": "\nSEMAPHORE_INFORMATION_CLASS is enumeration type used\nwith function \nNtQuerySemaphore. Currently only one class is defined:\nSemaphoreBasicInformation Result of\ncall to \nNtQuerySemaphore is \nSEMAPHORE_BASIC_INFORMATION structure.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtQuerySemaphore\nSEMAPHORE_BASIC_INFORMATION\n"
      },
      "NtQuerySemaphore": {
            "code": "NTSYSAPI \n    NTSTATUS\n    NTAPI\n    \n    NtQuerySemaphore(\n    \n    \n      IN HANDLE               SemaphoreHandle,\n      IN SEMAPHORE_INFORMATION_CLASS SemaphoreInformationClass,\n      OUT PVOID               SemaphoreInformation,\n      IN ULONG                SemaphoreInformationLength,\n      OUT PULONG              ReturnLength OPTIONAL );\n    \n    ",
            "description": "\n    \n    \n    \n    Function NtQuerySemaphore retrieve semaphore's\n    parameters (see \n    SEMAPHORE_BASIC_INFORMATION).\n    \n    \n    \n    \n    \n    \n    SemaphoreHandle HANDLE to\n    Semaphore Object opened with SEMAPHORE_QUERY_STATE\n    access.\n    \n    \n    \n    SemaphoreInformationClass Information\n    class descripted in \n    SEMAPHORE_INFORMATION_CLASS section.\n    \n    \n    \n    SemaphoreInformation Pointer to user's\n    allocated buffer for result data.\n    \n    \n    \n    SemaphoreInformationLength Size of\n    SemaphoreInformation buffer, in\n    bytes.\n    \n    \n    \n    ReturnLength Optionally returns\n    required buffer size.\n    \n    \n    \n    \n    \nDocumented by:\n    \n    Tomasz Nowak\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Requirements:\n    \n    \n    \nLibrary: ntdll.lib\n    \n    \n    \n    \n    \nSee also:\n    \n    \n    \n    NtCreateSemaphore\n    \n    \n    \n    NtOpenSemaphore\n    \n    \n    \n    SEMAPHORE_BASIC_INFORMATION\n    \n    \n    \n    SEMAPHORE_INFORMATION_CLASS\n    \n    \n    \n    \n    \n    "
      },
      "NtCreateProfile": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtCreateProfile(\n  OUT PHANDLE             ProfileHandle,\n  IN HANDLE               Process OPTIONAL,\n  IN PVOID                ImageBase,\n  IN ULONG                ImageSize,\n  IN ULONG                BucketSize,\n  IN PVOID                Buffer,\n  IN ULONG                BufferSize,\n  IN KPROFILE_SOURCE      ProfileSource,\n  IN KAFFINITY            Affinity );\n",
            "description": "\nFunction NtCreateProfile creates Profile Object.\nProfile Objects are used for application profiling. There're\n24 profile counters defined in \nKPROFILE_SOURCE enumeration type. Single Profile Object can be\nused to get information from one performance counter.\nProfileHandle Result of call -\nHANDLE to Profile Object.\nProcess HANDLE to Process Object\nto profile. Not required if profiled code is placed in Kernel\naddress space (above 0x80000000).\nImageBase Start address of\nprofiling.\nImageSize Size of profiled memory\nblock.\nBucketSize - ??? (cannot be less\nthan 2 ).\nBuffer Caller's allocated buffer for\ndata.\nBufferSize Size of buffer, in\nbytes.\nProfileSource Identifier of performance\ncounter. See \nKPROFILE_SOURCE enumeration type for possible values.\nAffinity Processor affinity mask. It\ndefines processors to ask about performance counter.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\nPrivileges for UserMode: SE_PROF_SINGLE_PROCESS_PRIVILEGE\nPrivileges for KernelMode: SE_SYSTEM_PROFILE_PRIVILEGE\n\nSee also:\nKPROFILE_SOURCE\nNtQueryIntervalProfile\nNtSetIntervalProfile\nNtStartProfile\nNtStopProfile\n"
      },
      "NtStopProfile": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtStopProfile(\n  IN HANDLE               ProfileHandle );\n",
            "description": "\nFunction NtStopProfile stops performance counter\nassociated with Profile Object.\nProfileHandle HANDLE to Profile\nObject, previously started with \nNtStartProfile function call.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCreateProfile\nNtStartProfile\n"
      },
      "KPROFILE_SOURCE": {
            "code": "\ntypedef enum _KPROFILE_SOURCE {\n    ProfileTime,\n    ProfileAlignmentFixup,\n    ProfileTotalIssues,\n    ProfilePipelineDry,\n    ProfileLoadInstructions,\n    ProfilePipelineFrozen,\n    ProfileBranchInstructions,\n    ProfileTotalNonissues,\n    ProfileDcacheMisses,\n    ProfileIcacheMisses,\n    ProfileCacheMisses,\n    ProfileBranchMispredictions,\n    ProfileStoreInstructions,\n    ProfileFpInstructions,\n    ProfileIntegerInstructions,\n    Profile2Issue,\n    Profile3Issue,\n    Profile4Issue,\n    ProfileSpecialInstructions,\n    ProfileTotalCycles,\n    ProfileIcacheIssues,\n    ProfileDcacheAccesses,\n    ProfileMemoryBarrierCycles,\n    ProfileLoadLinkedIssues,\n    ProfileMaximum\n} KPROFILE_SOURCE, *PKPROFILE_SOURCE;\n",
            "description": "\nEnumerated type KPROFILE_SOURCE is used as\nperformance counter identifier in application profiling. See\nNtCreateProfile for more information about Profile Objects.\nThis enumeration type is also defined in\n&lt;ntddk.h&gt; header file.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCreateProfile\nNtQueryIntervalProfile\nNtSetIntervalProfile\n"
      },
      "NtSetIntervalProfile": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtSetIntervalProfile(\n  IN ULONG                Interval,\n  IN KPROFILE_SOURCE      Source );\n",
            "description": "\nFunction NtSetIntervalProfile sets delay between\nperformance counter's ticks. Setting profile's interval has global\neffect for all running processes.\nUser can set interval only for software performance counters. To\ndetermine if counter is software or not, call \nNtQueryIntervalProfile. If returned interval is zero, queried\ncounter is hardware counter (build in CPU).\nInterval New interval, in ms.\nSource Performance counter's\nidentifier, defined in \nKPROFILE_SOURCE enumeration type.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nKPROFILE_SOURCE\nNtCreateProfile\nNtQueryIntervalProfile\n"
      },
      "NtStartProfile": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtStartProfile(\n  IN HANDLE               ProfileHandle );\n",
            "description": "\nFunction NtStartProfile starts performance counter\nassiciated with previously created Profile Object.\nProfileHandle HANDLE to Profile\nObject.\nCounter is stopped when user call \nNtStopProfile.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCreateProfile\nNtStopProfile\n"
      },
      "NtQueryIntervalProfile": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtQueryIntervalProfile(\n  IN KPROFILE_SOURCE      ProfileSource,\n  OUT PULONG              Interval );\n",
            "description": "\nFunction NtQueryIntervalProfile retrieves currently\nset delay between performance counter's ticks. See also description\nof \nNtSetIntervalProfile function.\nProfileSource Performance counter\nidentifier defined in \nKPROFILE_SOURCE enumeration type.\nInterval Pointer to ULONG value\nreceiving current interval, in ms. If received value is\nzero, counter specified in ProfileSource parameter is hardware counter\n(performacne counter build in CPU).\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nKPROFILE_SOURCE\nNtCreateProfile\nNtSetIntervalProfile\n"
      },
      "NtQuerySymbolicLinkObject": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtQuerySymbolicLinkObject(\n  IN HANDLE               SymbolicLinkHandle,\n  OUT PUNICODE_STRING     pLinkName,\n  OUT PULONG              pDataWritten OPTIONAL );\n",
            "description": "\npLinkName\n"
      },
      "NtOpenSymbolicLinkObject": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtOpenSymbolicLinkObject(\n  OUT PHANDLE             pHandle,\n  IN ACCESS_MASK          DesiredAccess,\n  IN POBJECT_ATTRIBUTES   ObjectAttributes );\n",
            "description": "\n"
      },
      "NtCreateSymbolicLinkObject": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtCreateSymbolicLinkObject (\n  OUT PHANDLE             pHandle,\n  IN ACCESS_MASK          DesiredAccess,\n  IN POBJECT_ATTRIBUTES   ObjectAttributes,\n  IN PUNICODE_STRING      DestinationName );\n",
            "description": "\npHandle\n"
      },
      "NtQueryDirectoryObject": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtQueryDirectoryObject(\n  IN HANDLE               DirectoryObjectHandle,\n  OUT POBJDIR_INFORMATION DirObjInformation,\n  IN ULONG                BufferLength,\n  IN BOOLEAN              GetNextIndex,\n  IN BOOLEAN              IgnoreInputIndex,\n  IN OUT PULONG           ObjectIndex,\n  OUT PULONG              DataWritten OPTIONAL );\n",
            "description": "\n"
      },
      "NtOpenDirectoryObject": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtOpenDirectoryObject(\n  OUT PHANDLE             DirectoryObjectHandle,\n  IN ACCESS_MASK          DesiredAccess,\n  IN POBJECT_ATTRIBUTES   ObjectAttributes );\n",
            "description": "\n"
      },
      "NtCreateDirectoryObject": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtCreateDirectoryObject(\n  OUT PHANDLE             DirectoryHandle,\n  IN ACCESS_MASK          DesiredAccess,\n  IN POBJECT_ATTRIBUTES   ObjectAttributes );\n",
            "description": "\n"
      },
      "NtWaitLowEventPair": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtWaitLowEventPair(\n  IN HANDLE               EventPairHandle );\n",
            "description": "\nFunction waits, until LOW event will be signaled.\n"
      },
      "NtSetLowWaitHighEventPair": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtSetLowWaitHighEventPair(\n  IN HANDLE               EventPairHandle );\n",
            "description": "\nFunction set signalled state to LOW event and wait until HIGH event will be signaled.\n"
      },
      "NtSetHighWaitLowThread": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtSetHighWaitLowThread(\n );\n",
            "description": "\n- ???\n"
      },
      "NtSetLowWaitHighThread": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtSetLowWaitHighThread(\n );\n",
            "description": "\nFunction NtSetLowWaitHighThread is obsolete and exist\nup to NT 4.0.\n(?)\nSee also \nNtSetInformationThread with \nThreadEventPair information class.\n\nDocumented by:\nSven B. Schreiber\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCreateEventPair\nNtOpenEventPair\nNtSetInformationThread\nNtSetLowEventPair\nNtSetLowWaitHighEventPair\nNtWaitHighEventPair\nTHREAD_INFORMATION_CLASS\n"
      },
      "NtSetHighWaitLowEventPair": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtSetHighWaitLowEventPair(\n  IN HANDLE               EventPairHandle );\n",
            "description": "\nFunction signals HIGH event and waits unlit LOW event will be signaled.\n"
      },
      "NtWaitHighEventPair": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtWaitHighEventPair(\n  IN HANDLE               EventPairHandle );\n",
            "description": "\nWait until HIGH event of EventPairHandle will be signaled.\n"
      },
      "NtOpenEventPair": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtOpenEventPair(\n  OUT PHANDLE             EventPairHandle,\n  IN ACCESS_MASK          DesiredAccess,\n  IN POBJECT_ATTRIBUTES   ObjectAttributes );\n",
            "description": "\nDesiredAccess\nSee NtCreateEventPair for definitions of EventPair possibble access rights.\n"
      },
      "NtSetHighEventPair": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtSetHighEventPair(\n  IN HANDLE               EventPairHandle );\n",
            "description": "\nFunction sets HIGH event state to signalled.\n"
      },
      "NtCreateEventPair": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtCreateEventPair(\n  OUT PHANDLE             EventPairHandle,\n  IN ACCESS_MASK          DesiredAccess,\n  IN POBJECT_ATTRIBUTES   ObjectAttributes OPTIONAL );\n",
            "description": "\nEventPairHandle\nResult handle to EventPair object.\n"
      },
      "NtSetLowEventPair": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtSetLowEventPair(\n  IN HANDLE               EventPairHandle );\n",
            "description": "\nFunction sets LOW event for EventPairHandle object.\n"
      },
      "NtReadRequestData": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtReadRequestData(\n  IN HANDLE               PortHandle,\n  IN PLPC_MESSAGE         Request,\n  IN ULONG                DataIndex,\n  OUT PVOID               Buffer,\n  IN ULONG                Length,\n  OUT PULONG              ResultLength OPTIONAL );\n",
            "description": "\nPortHandle HANDLE to Port Object\nopened in a result of call \nNtAcceptConnectPort.\nRequest \nDataIndex \nBuffer \nLength \nResultLength \n\nDocumented by:\nBo Branten\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nLPC_MESSAGE\nNtAcceptConnectPort\nNtWriteRequestData\n"
      },
      "NtRequestPort": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtRequestPort(\n  IN HANDLE               PortHandle,\n  IN PLPC_MESSAGE         Request );\n",
            "description": "\nNtRequestPort sends request message to other side of\nLPC connection.\nPortHandle HANDLE to Port\nObject.\nRequest Pointer to \nLPC_MESSAGE struct contains request data.\n\nDocumented by:\nTomasz Nowak\nBo Branten\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nLPC_MESSAGE\nNtAcceptConnectPort\nNtConnectPort\nNtListenPort\nNtReplyPort\nNtRequestWaitReplyPort\n"
      },
      "NtReplyPort": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtReplyPort(\n  IN HANDLE               PortHandle,\n  IN PLPC_MESSAGE         Reply );\n",
            "description": "\nNtReplyPort can be used by both sides of LPC\nconnection.\nPortHandle HANDLE to Port\nObject.\nReply Pointer to \nLPC_MESSAGE structure.\n\nDocumented by:\nTomasz Nowak\nBo Branten\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtAcceptConnectPort\nNtConnectPort\nNtReplyWaitReceivePort\nNtReplyWaitReplyPort\nNtRequestWaitReplyPort\n"
      },
      "LPC_MESSAGE": {
            "code": "\ntypedef struct _LPC_MESSAGE {\n  USHORT                  DataLength;\n  USHORT                  Length;\n  USHORT                  MessageType;\n  USHORT                  DataInfoOffset;\n  CLIENT_ID               ClientId;\n  ULONG                   MessageId;\n  ULONG                   CallbackId;\n} LPC_MESSAGE, *PLPC_MESSAGE;\n",
            "description": "\nStructure LPC_MESSAGE it's a header for all\nLPC messages. Any LPC message must contains at least\n0x18 bytes length for LPC_MESSAGE header.\nDataLength Length of additional data in\nmessage. Maximum length of data is 0x130 bytes.\nLength Length of message, including\nheader. Maximum value is 0x148 bytes length.\nMessageType Type of message. This field\nis filled by system in message transfer process. Can be one of\nfollowing:\nLPC_REQUEST\nLPC_REPLY\nLPC_DATAGRAM\nLPC_LOST_REPLY\nLPC_PORT_CLOSED\nLPC_CLIENT_DIED\nLPC_EXCEPTION\nLPC_DEBUG_EVENT\nLPC_ERROR_EVENT\nLPC_CONNECTION_REQUEST\nDataInfoOffset \nClientId Port's client unique\nidentifier.\nMessageId System set this field to\nactual value of incremental message counter.\nCallbackId \nStructure is known also as LPC_MESSAGE_HEADER.\n\nDocumented by:\nBo Branten\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtAcceptConnectPort\nNtImpersonateClientOfPort\nNtListenPort\nNtReadRequestData\nNtReplyPort\nNtReplyWaitReceivePort\nNtReplyWaitReplyPort\nNtRequestPort\nNtRequestWaitReplyPort\nNtWriteRequestData\n"
      },
      "NtAcceptConnectPort": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtAcceptConnectPort(\n  OUT PHANDLE             ServerPortHandle,\n  IN HANDLE               AlternativeReceivePortHandle OPTIONAL,\n  IN PLPC_MESSAGE         ConnectionReply,\n  IN BOOLEAN              AcceptConnection,\n  IN OUT PLPC_SECTION_OWNER_MEMORY ServerSharedMemory OPTIONAL,\n  OUT PLPC_SECTION_MEMORY ClientSharedMemory OPTIONAL );\n",
            "description": "\nNtAcceptConnectPort function is used in LPC\ncommunication by server process for establish connection with\nclient. It should be called after NtListenPort completes.\nServerPortHandle Result of call -\nHANDLE to Port Object for established connection.\nAlternativeReceivePortHandle \nConnectionReply Pointer to \nLPC_MESSAGE structure received from NtListenPort.\nAcceptConnection If not set, connection\non client's side will be refused.\nServerSharedMemory If connection uses\nlarge data buffers, and a HANDLE to Section Object for\nshared memory window is created on server side, server process\nshout set this parameter to pointer to \nLPC_SECTION_OWNER_MEMORY structure with filled\nSectionHandle member.\nClientSharedMemory Similar to\nServerSharedMemory, but when\nconnection client create Section Object. In this case server\ndoesn't know section's HANDLE, but shared memory window is\nautomatically maped to his address space. Size and base address of\nmapped memory are returned in \nLPC_SECTION_MEMORY structure.\nThis function returns HANDLE to newly created Port Object.\nAll other LPC functions for currently accepted connection\nshould use this HANDLE, not a base named port HANDLE\ncreated with \nNtCreatePort.\n\nDocumented by:\nTomasz Nowak\nBo Branten\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nLPC_MESSAGE\nLPC_SECTION_MEMORY\nLPC_SECTION_OWNER_MEMORY\nNtCompleteConnectPort\nNtCreatePort\nNtListenPort\n"
      },
      "NtRequestWaitReplyPort": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtRequestWaitReplyPort(\n  IN HANDLE               PortHandle,\n  IN PLPC_MESSAGE         Request,\n  OUT PLPC_MESSAGE        IncomingReply );\n",
            "description": "\nNtRequestWaitReplyPort is used typically by client\nside in LPC connection.\nPortHandle HANDLE to Port\nObject.\nRequest Pointer to \nLPC_MESSAGE buffer contains request data.\nIncomingReply Pointer to \nLPC_MESSAGE buffer filled on return with reply from other\nside.\n\nDocumented by:\nTomasz Nowak\nBo Branten\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nLPC_MESSAGE\nNtAcceptConnectPort\nNtConnectPort\nNtReplyPort\nNtReplyWaitReceivePort\nNtReplyWaitReplyPort\nNtRequestPort\n"
      },
      "NtReplyWaitReceivePort": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtReplyWaitReceivePort(\n  IN HANDLE               PortHandle,\n  OUT PHANDLE             ReceivePortHandle OPTIONAL,\n  IN PLPC_MESSAGE         Reply OPTIONAL,\n  OUT PLPC_MESSAGE        IncomingRequest );\n",
            "description": "\nNtReplyWaitReceivePort is typically used by\nLPC server process for receive LPC requests incomming\nfrom client process.\nPortHandle HANDLE to Port Object\nreturned by\nReceivePortHandle \nReply If other side waiting for reply\nmessage, you can send it by specyfing LPC Message Buffer as\nthis parameter.\nIncomingRequest Pointer to user's\nallocated buffer receiving request data. Received data starts\nwith\n\nDocumented by:\nTomasz Nowak\nBo Branten\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nLPC_MESSAGE\nNtAcceptConnectPort\nNtReplyPort\nNtReplyWaitReplyPort\nNtRequestPort\nNtRequestWaitReplyPort\n"
      },
      "LPC_SECTION_MEMORY": {
            "code": "\ntypedef struct _LPC_SECTION_MEMORY {\n  ULONG                   Length;\n  ULONG                   ViewSize;\n  PVOID                   ViewBase;\n} LPC_SECTION_MEMORY, *PLPC_SECTION_MEMORY;\n",
            "description": "\nStructure is used with LPC connection functions: NtAcceptConnectPort on server's side\nand NtConnectPort on client's\nside. It receives information about mapped view of section. Section\nObject must be created by other side (see \nLPC_SECTION_OWNER_MEMORY).\nLength Length of structure, in\nbytes.\nViewSize Size of memory window, in\nbytes. This member is filled by LPC connection\nfunction.\nViewBase Base address of memory window\nin current process memory space.\n\nDocumented by:\nTomasz Nowak\nBo Branten\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nLPC_SECTION_OWNER_MEMORY\nNtAcceptConnectPort\nNtConnectPort\nNtMapViewOfSection\n"
      },
      "NtQueryInformationPort": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtQueryInformationPort(\n  IN HANDLE               PortHandle,\n  IN PORT_INFORMATION_CLASS PortInformationClass,\n  OUT PVOID               PortInformation,\n  IN ULONG                Length,\n  OUT PULONG              ResultLength OPTIONAL );\n",
            "description": "\nCurrently (on WinNT 4.0 SP6) there are no information\nclasses for Port Object.\nPortHandle \nPortInformationClass \nPortInformation \nLength \nResultLength \n\nDocumented by:\nTomasz Nowak\nBo Branten\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nPORT_INFORMATION_CLASS\n"
      },
      "LPC_TERMINATION_MESSAGE": {
            "code": "\ntypedef struct _LPC_TERMINATION_MESSAGE {\n  LPC_MESSAGE_HEADER      Header;\n  LARGE_INTEGER           CreationTime;\n} LPC_TERMINATION_MESSAGE, *PLPC_TERMINATION_MESSAGE;\n",
            "description": "\nLPC_TERMINATION_MESSAGE is send to LPC server\nprocess when thread is terminating. Thread must be registered for\ninform server process by call \nNtRegisterThreadTerminatePort.\nThis message type is also send when LPC client close\nconnection to server's port.\nHeader Header.MessageType is LPC_CLIENT_DIED\nwhen thread terminate.\nHeader.MessageType is LPC_PORT_CLOSED\nwhen LPC client close connection.\nSee \nLPC_MESSAGE for details.\nCreationTime Time of thread creation or\ntime of connection begin.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nLPC_MESSAGE\nNtConnectPort\nNtRegisterThreadTerminatePort\n"
      },
      "PORT_INFORMATION_CLASS": {
            "code": "\ntypedef enum _PORT_INFORMATION_CLASS {\n    PortNoInformation\n} PORT_INFORMATION_CLASS, *PPORT_INFORMATION_CLASS;\n",
            "description": "\nPortNoInformation Currently (on\nWinNT 4.0 SP6) there are no information classes for\nPort Objects.\n\nDocumented by:\nBo Branten\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtQueryInformationPort\n"
      },
      "NtConnectPort": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtConnectPort(\n  OUT PHANDLE             ClientPortHandle,\n  IN PUNICODE_STRING      ServerPortName,\n  IN PSECURITY_QUALITY_OF_SERVICE SecurityQos,\n  IN OUT PLPC_SECTION_OWNER_MEMORY ClientSharedMemory OPTIONAL,\n  OUT PLPC_SECTION_MEMORY ServerSharedMemory OPTIONAL,\n  OUT PULONG              MaximumMessageLength OPTIONAL,\n  IN                      ConnectionInfo OPTIONAL,\n  IN PULONG               ConnectionInfoLength OPTIONAL );\n",
            "description": "\nNtConnectPort is used by client process for establish\nLPC connection with Named Port's owner.\nClientPortHandle Result of call -\nHANDLE to Port Object.\nServerPortName Name of port to connect\nto.\nSecurityQos \nClientSharedMemory Used when calling\nprocess created Section Object for shared memory. See \nNtAcceptConnectPort for details.\nServerSharedMemory Used when calling\nprocess didn't create Section Object. See \nNtAcceptConnectPort for details.\nMaximumMessageLength Maximum\ncommunication message length. This value is calculated by server on\nport creation process (see \nNtCreatePort).\nConnectionInfo Pointer to RAW buffer\ncontaining information from client. That information is received by\nserver through \nLPC_MESSAGE with MessageType\nfield set to LPC_CONNECTION_REQUEST.\nConnectionInfoLength Size of\nConnectionInfo buffer, in\nbytes.\n\nDocumented by:\nTomasz Nowak\nBo Branten\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nLPC_MESSAGE\nLPC_SECTION_MEMORY\nLPC_SECTION_OWNER_MEMORY\nNtAcceptConnectPort\nNtCompleteConnectPort\nNtCreatePort\n"
      },
      "NtWriteRequestData": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtWriteRequestData(\n  IN HANDLE               PortHandle,\n  IN PLPC_MESSAGE         Request,\n  IN ULONG                DataIndex,\n  IN PVOID                Buffer,\n  IN ULONG                Length,\n  OUT PULONG              ResultLength OPTIONAL );\n",
            "description": "\nPortHandle HANDLE to Port Object\nopened in a result of call \nNtAcceptConnectPort.\nRequest \nDataIndex \nBuffer \nLength \nResultLength \n\nDocumented by:\nBo Branten\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nLPC_MESSAGE\nNtAcceptConnectPort\nNtReadRequestData\n"
      },
      "NtCompleteConnectPort": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtCompleteConnectPort(\n  IN HANDLE               PortHandle );\n",
            "description": "\nNtCompleteConnectPort is called by server process\nafter all initializations for new connection.\nPortHandle HANDLE to Port Object\nreceived with NtAcceptConnectPort call.\nReturn from NtConnectPort on\nclient's side is synchronised with return from this call. Both\nsides of LPC connection are ready for sending and receiving\nLPC messages.\n\nDocumented by:\nTomasz Nowak\nBo Branten\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtAcceptConnectPort\nNtConnectPort\n"
      },
      "LPC_SECTION_OWNER_MEMORY": {
            "code": "\ntypedef struct _LPC_SECTION_OWNER_MEMORY {\n  ULONG                   Length;\n  HANDLE                  SectionHandle;\n  ULONG                   OffsetInSection;\n  ULONG                   ViewSize;\n  PVOID                   ViewBase;\n  PVOID                   OtherSideViewBase;\n} LPC_SECTION_OWNER_MEMORY, *PLPC_SECTION_OWNER_MEMORY;\n",
            "description": "\nThis structure is used by LPC connection functions by\nSection Object creator side (whatever it is client of port or\nserver). See \nLPC_SECTION_MEMORY for more information.\nLength Length of structure.\nSectionHandle HANDLE to\nSectionObject mapped on both sides of LPC connection.\nOffsetInSection \nViewSize Receives size of mapped\nwindow.\nViewBase Receives base address of\nmapped window.\nOtherSideViewBase Receives base address\nof mapped window for other LPC connection side.\n\nDocumented by:\nTomasz Nowak\nBo Branten\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nLPC_SECTION_MEMORY\nNtAcceptConnectPort\nNtConnectPort\nNtCreateSection\nNtMapViewOfSection\n"
      },
      "NtImpersonateClientOfPort": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtImpersonateClientOfPort(\n  IN HANDLE               PortHandle,\n  IN PLPC_MESSAGE         Request );\n",
            "description": "\nNtImpersonateClientOfPort is called by LPC server\nprocess to get security context of client. That means: client's\nToken Object is assiciated with calling server thread (like\nNtSetInformationThread with \nThreadImpersonationToken information class).\nPortHandle HANDLE to Port Object\nopened with \nNtAcceptConnectPort call.\nRequest Pointer to \nLPC_MESSAGE structure contains reason of impersonation.\n\nDocumented by:\nTomasz Nowak\nBo Branten\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nLPC_MESSAGE\nNtAcceptConnectPort\nNtOpenThreadToken\nNtQueryInformationThread\nNtSetInformationThread\n"
      },
      "NtReplyWaitReplyPort": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtReplyWaitReplyPort(\n  IN HANDLE               PortHandle,\n  IN OUT PLPC_MESSAGE     Reply );\n",
            "description": "\nNtReplyWaitReplyPort sends REPLY and waits for other\nside REPLY.\nPortHandle HANDLE to Port\nObject.\nReply There's a pointer to \nLPC_MESSAGE structure. On input, should be filled with REPLY\ndata by user. On output it contains REPLY from other side.\n\nDocumented by:\nTomasz Nowak\nBo Branten\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nLPC_MESSAGE\nNtAcceptConnectPort\nNtConnectPort\nNtReplyPort\nNtReplyWaitReceivePort\nNtRequestWaitReplyPort\n"
      },
      "NtListenPort": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtListenPort(\n  IN HANDLE               PortHandle,\n  OUT PLPC_MESSAGE        ConnectionRequest );\n",
            "description": "\nNtListenPort is used by LPC server.\nPortHandle HANDLE to named Port\nObject, created with \nNtCreatePort.\nConnectionRequest Result of call -\npointer to structure \nLPC_MESSAGE filled with incomming connection data.\nServer process should create new thread starting from execution of\nNtAcceptConnectPort. Main thread should call\nNtListenPort again to make possible for other\nprocesses to connect to port.\n\nDocumented by:\nTomasz Nowak\nBo Branten\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nLPC_MESSAGE\nNtAcceptConnectPort\nNtConnectPort\nNtCreatePort\n"
      },
      "NtCreatePort": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtCreatePort(\n  OUT PHANDLE             PortHandle,\n  IN POBJECT_ATTRIBUTES   ObjectAttributes,\n  IN ULONG                MaxConnectInfoLength,\n  IN ULONG                MaxDataLength,\n  IN OUT PULONG           Reserved OPTIONAL );\n",
            "description": "\nPortHandle Result of call -\nHANDLE to Port Object.\nObjectAttributes Typically contains\nname and SECURITY_DESCRIPTOR for newly created named\nport.\nMaxConnectInfoLength \nMaxDataLength Maximum size of\nmessage.\nReserved \n\nDocumented by:\nBo Branten\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtConnectPort\nNtListenPort\n"
      },
      "NtTerminateThread": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtTerminateThread(\n  IN HANDLE               ThreadHandle,\n  IN NTSTATUS             ExitStatus );\n",
            "description": "\nThreadHandle\nOpen handle to thread object.\n"
      },
      "NtRegisterThreadTerminatePort": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtRegisterThreadTerminatePort(\n  IN HANDLE               PortHandle );\n",
            "description": "\nPortHandle HANDLE to previously\nconnected Port Object.\nTypically, NtRegisterThreadTerminatePort is used in\nCsrNewThread function, called\nbefore thread execution begins, but in thread context.\nFunction associate PortHandle\nwith thread, and sends LPC_TERMINATION_MESSAGE to\nspecified port immediatelly after call \nNtTerminateThread.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nCsrNewThread\nLPC_TERMINATION_MESSAGE\nNtConnectPort\nNtTerminateThread\n"
      },
      "NtAlertResumeThread": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtAlertResumeThread(\n  IN HANDLE               ThreadHandle,\n  OUT PULONG              SuspendCount );\n",
            "description": "\nThreadHandle\nHandle to thread object.\n"
      },
      "NtResumeThread": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtResumeThread(\n  IN HANDLE               ThreadHandle,\n  OUT PULONG              SuspendCount OPTIONAL );\n",
            "description": "\nSee AlertResumeThread.\n"
      },
      "NtCreateThread": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtCreateThread(\n  OUT PHANDLE             ThreadHandle,\n  IN ACCESS_MASK          DesiredAccess,\n  IN POBJECT_ATTRIBUTES   ObjectAttributes OPTIONAL,\n  IN HANDLE               ProcessHandle,\n  OUT PCLIENT_ID          ClientId,\n  IN PCONTEXT             ThreadContext,\n  IN PINITIAL_TEB         InitialTeb,\n  IN BOOLEAN              CreateSuspended );\n",
            "description": "\nThreadHandle\nCaller supplied storage for the resulting\nhandle.\n"
      },
      "NtContinue": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtContinue(\n  IN PCONTEXT             ThreadContext,\n  IN BOOLEAN              RaiseAlert );\n",
            "description": "\nThreadContext Pointer to CONTEXT\nstructure for current thread.\nRaiseAlert If set, remove\nAlerted state from current Thread Object.\nYou can use NtContinue after processing exception for\ncontinue executing thread. System uses NtContinue\nalso in APC processing.\n\nDocumented by:\nTomasz Nowak\nReactos\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCreateThread\nNtGetContextThread\nNtSetContextThread\n"
      },
      "NtQueryInformationThread": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtQueryInformationThread(\n  IN HANDLE               ThreadHandle,\n  IN THREAD_INFORMATION_CLASS ThreadInformationClass,\n  OUT PVOID               ThreadInformation,\n  IN ULONG                ThreadInformationLength,\n  OUT PULONG              ReturnLength OPTIONAL );\n",
            "description": "\n"
      },
      "THREAD_INFORMATION_CLASS": {
            "code": "\ntypedef enum _THREAD_INFORMATION_CLASS {\n    ThreadBasicInformation,\n    ThreadTimes,\n    ThreadPriority,\n    ThreadBasePriority,\n    ThreadAffinityMask,\n    ThreadImpersonationToken,\n    ThreadDescriptorTableEntry,\n    ThreadEnableAlignmentFaultFixup,\n    ThreadEventPair,\n    ThreadQuerySetWin32StartAddress,\n    ThreadZeroTlsCell,\n    ThreadPerformanceCount,\n    ThreadAmILastThread,\n    ThreadIdealProcessor,\n    ThreadPriorityBoost,\n    ThreadSetTlsArrayAddress,\n    ThreadIsIoPending,\n    ThreadHideFromDebugger\n} THREAD_INFORMATION_CLASS, *PTHREAD_INFORMATION_CLASS;\n",
            "description": "\nTHREAD_INFORMATION_CLASS is information class enumerated type for use with NtQueryInformationThread and NtSetInformationThread calls.\n"
      },
      "NtYieldExecution": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtYieldExecution(\n );\n",
            "description": "\nThis function stop executing of calling thread, and switch to any other currently running thread.\n"
      },
      "NtImpersonateThread": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtImpersonateThread(\n  IN HANDLE               ThreadHandle,\n  IN HANDLE               ThreadToImpersonate,\n  IN PSECURITY_QUALITY_OF_SERVICE SecurityQualityOfService );\n",
            "description": "\nFunction NtImpersonateThread assigns one thread's\ntoken to another. If source thread don't have associated Token\nObject, function use process'es token to impersonate destination\nthread.\nThreadHandle HANDLE to source\nThread Object.\nThreadToImpersonate HANDLE to\ndestination Thread Object opened with THREAD_IMPERSONATE\naccess.\nSecurityQualityOfService Pointer to\nSECURITY_QUALITY_OF_SERVICE\nstructure filled by user.\n\nDocumented by:\nTomasz Nowak\nReactos\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCreateThread\nNtImpersonateClientOfPort\nNtOpenThread\nSECURITY_QUALITY_OF_SERVICE\n"
      },
      "NtOpenThread": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtOpenThread(\n  OUT PHANDLE             ThreadHandle,\n  IN ACCESS_MASK          AccessMask,\n  IN POBJECT_ATTRIBUTES   ObjectAttributes,\n  IN PCLIENT_ID           ClientId );\n",
            "description": "\nThreadHandle\nPointer to received handle to thread object.\n"
      },
      "TEB": {
            "code": "\ntypedef struct _TEB {\n  NT_TIB                  Tib;\n  PVOID                   EnvironmentPointer;\n  CLIENT_ID               Cid;\n  PVOID                   ActiveRpcInfo;\n  PVOID                   ThreadLocalStoragePointer;\n  PPEB                    Peb;\n  ULONG                   LastErrorValue;\n  ULONG                   CountOfOwnedCriticalSections;\n  PVOID                   CsrClientThread;\n  PVOID                   Win32ThreadInfo;\n  ULONG                   Win32ClientInfo[0x1F];\n  PVOID                   WOW32Reserved;\n  ULONG                   CurrentLocale;\n  ULONG                   FpSoftwareStatusRegister;\n  PVOID                   SystemReserved1[0x36];\n  PVOID                   Spare1;\n  ULONG                   ExceptionCode;\n  ULONG                   SpareBytes1[0x28];\n  PVOID                   SystemReserved2[0xA];\n  ULONG                   GdiRgn;\n  ULONG                   GdiPen;\n  ULONG                   GdiBrush;\n  CLIENT_ID               RealClientId;\n  PVOID                   GdiCachedProcessHandle;\n  ULONG                   GdiClientPID;\n  ULONG                   GdiClientTID;\n  PVOID                   GdiThreadLocaleInfo;\n  PVOID                   UserReserved[5];\n  PVOID                   GlDispatchTable[0x118];\n  ULONG                   GlReserved1[0x1A];\n  PVOID                   GlReserved2;\n  PVOID                   GlSectionInfo;\n  PVOID                   GlSection;\n  PVOID                   GlTable;\n  PVOID                   GlCurrentRC;\n  PVOID                   GlContext;\n  NTSTATUS                LastStatusValue;\n  UNICODE_STRING          StaticUnicodeString;\n  WCHAR                   StaticUnicodeBuffer[0x105];\n  PVOID                   DeallocationStack;\n  PVOID                   TlsSlots[0x40];\n  LIST_ENTRY              TlsLinks;\n  PVOID                   Vdm;\n  PVOID                   ReservedForNtRpc;\n  PVOID                   DbgSsReserved[0x2];\n  ULONG                   HardErrorDisabled;\n  PVOID                   Instrumentation[0x10];\n  PVOID                   WinSockData;\n  ULONG                   GdiBatchCount;\n  ULONG                   Spare2;\n  ULONG                   Spare3;\n  ULONG                   Spare4;\n  PVOID                   ReservedForOle;\n  ULONG                   WaitingOnLoaderLock;\n  PVOID                   StackCommit;\n  PVOID                   StackCommitMax;\n  PVOID                   StackReserved;\n} TEB, *PTEB;\n",
            "description": "\nStructure TEB (Thread Environment Block) is\nmemory block containing system variables placed in User-Mode\nmemory. Every created thread have own TEB block. User\ncan get address of TEB by call NtCurrentTeb function.\nTib Structure NT_TIB is\navaiable in &lt;WinNT.h&gt; header file.\nEnvironmentPointer \nCid \nActiveRpcInfo \nThreadLocalStoragePointer \nPeb Pointer to PEB\nstructure contains Process Environment Block.\nLastErrorValue \nCountOfOwnedCriticalSections \nCsrClientThread \nWin32ThreadInfo \nWin32ClientInfo[0x1F] \nWOW32Reserved \nCurrentLocale \nFpSoftwareStatusRegister \nSystemReserved1[0x36] \nSpare1 \nExceptionCode \nSpareBytes1[0x28] \nSystemReserved2[0xA] \nGdiRgn \nGdiPen \nGdiBrush \nRealClientId \nGdiCachedProcessHandle \nGdiClientPID \nGdiClientTID \nGdiThreadLocaleInfo \nUserReserved[5] \nGlDispatchTable[0x118] \nGlReserved1[0x1A] \nGlReserved2 \nGlSectionInfo \nGlSection \nGlTable \nGlCurrentRC \nGlContext \nLastStatusValue \nStaticUnicodeString \nStaticUnicodeBuffer[0x105] \nDeallocationStack \nTlsSlots[0x40] \nTlsLinks \nVdm \nReservedForNtRpc \nDbgSsReserved[0x2] \nHardErrorDisabled \nInstrumentation[0x10] \nWinSockData \nGdiBatchCount \nSpare2 \nSpare3 \nSpare4 \nReservedForOle \nWaitingOnLoaderLock \nStackCommit \nStackCommitMax \nStackReserved \n\nDocumented by:\nReactos\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCurrentTeb\nPEB\nTHREAD_BASIC_INFORMATION\n"
      },
      "NtDelayExecution": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtDelayExecution(\n  IN BOOLEAN              Alertable,\n  IN PLARGE_INTEGER       DelayInterval );\n",
            "description": "\nAlertable If set, execution can break\nin a result of NtAlertThread\ncall.\nDelayInterval Delay in 100-ns units.\nNegative value means delay relative to current.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtAlertThread\nNtSignalAndWaitForSingleObject\nNtWaitForMultipleObjects\nNtWaitForSingleObject\n"
      },
      "NtSuspendThread": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtSuspendThread(\n  IN HANDLE               ThreadHandle,\n  OUT PULONG              PreviousSuspendCount OPTIONAL );\n",
            "description": "\nPreviousSuspendCount\nSuspend count for ThreadHandle thread before function call.\n"
      },
      "NtSetInformationThread": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtSetInformationThread(\n  IN HANDLE               ThreadHandle,\n  IN THREAD_INFORMATION_CLASS ThreadInformationClass,\n  IN PVOID                ThreadInformation,\n  IN ULONG                ThreadInformationLength );\n",
            "description": "\n"
      },
      "NtSetContextThread": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtSetContextThread(\n  IN HANDLE               ThreadHandle,\n  IN PCONTEXT             Context );\n",
            "description": "\n"
      },
      "NtGetContextThread": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtGetContextThread(\n  IN HANDLE               ThreadHandle,\n  OUT PCONTEXT            pContext );\n",
            "description": "\npContext\nSee &lt;ntddk.h&gt; for information about CONTEXT structure usage.\n"
      },
      "RtlInitializeContext": {
            "code": "\nNTSYSAPI \nPVOID\nNTAPI\nRtlInitializeContext(\n  IN HANDLE               ProcessHandle,\n  OUT PCONTEXT            ThreadContext,\n  IN PVOID                ThreadStartParam OPTIONAL,\n  IN PTHREAD_START_ROUTINE ThreadStartAddress,\n  IN PINITIAL_TEB     InitialTeb );\n",
            "description": "\nInitialise CONTEXT structure for use with NtCreateThread. \n"
      },
      "NtCreateEvent": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtCreateEvent(\n  OUT PHANDLE             EventHandle,\n  IN ACCESS_MASK          DesiredAccess,\n  IN POBJECT_ATTRIBUTES   ObjectAttributes OPTIONAL,\n  IN EVENT_TYPE           EventType,\n  IN BOOLEAN              InitialState );\n",
            "description": "\nEventHandle Result of call -\nHANDLE to newly created Event Object.\nDesiredAccess Assess rights associated\nwith created event. Can be one of following values from\n&lt;winnt.h&gt;:\nEVENT_QUERY_STATE\nEVENT_MODIFY_STATE\nEVENT_ALL_ACCESS\nObjectAttributes Optional name of Event\nObject for multiprocess use.\nEventType See \nEVENT_TYPE for details.\nInitialState State of event\nimmediatelly after creation.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nEVENT_TYPE\nNtOpenEvent\n"
      },
      "EVENT_BASIC_INFORMATION": {
            "code": "\ntypedef struct _EVENT_BASIC_INFORMATION {\n  EVENT_TYPE              EventType;\n  LONG                    EventState;\n} EVENT_BASIC_INFORMATION, *PEVENT_BASIC_INFORMATION;\n",
            "description": "\nThis structure is used with \nEventBasicInformation information class as a result of call\nNtQueryEvent.\nEventType Type of Event Object. Can be\nSynchronizationEvent or\nNotificationEvent.\nSee \nEVENT_TYPE for details.\nEventState Current state of Event\nObject.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nEVENT_INFORMATION_CLASS\nEVENT_TYPE\nNtQueryEvent\n"
      },
      "NtSetEvent": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtSetEvent(\n  IN HANDLE               EventHandle,\n  OUT PLONG               PreviousState OPTIONAL );\n",
            "description": "\nEventHandle HANDLE to Event\nObject opened with EVENT_MODIFY_STATE access.\nPreviousState State of Event Object\nbefore function call.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtClearEvent\nNtCreateEvent\nNtOpenEvent\nNtResetEvent\n"
      },
      "NtQueryEvent": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtQueryEvent(\n  IN HANDLE               EventHandle,\n  IN EVENT_INFORMATION_CLASS EventInformationClass,\n  OUT PVOID               EventInformation,\n  IN ULONG                EventInformationLength,\n  OUT PULONG              ReturnLength OPTIONAL );\n",
            "description": "\nEventHandle HANDLE to Event\nObject opened with EVENT_QUERY_STATE access.\nEventInformationClass See \nEVENT_INFORMATION_CLASS for details.\nEventInformation Caller's allocated\nbuffer for result data.\nEventInformationLength Length of\nEventInformation buffer, in\nbytes.\nReturnLength Returns required/used size\nof EventInformation buffer.\nCurrently there're only one information class for use with Event\nObject. See \nEVENT_INFORMATION_CLASS for details.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nEVENT_BASIC_INFORMATION\nEVENT_INFORMATION_CLASS\nNtCreateEvent\nNtOpenEvent\n"
      },
      "NtClearEvent": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtClearEvent(\n  IN HANDLE               EventHandle );\n",
            "description": "\nEventHandle HANDLE to Event\nObject opened with EVENT_MODIFY_STATE attribute.\nThere're no functional difference between\nNtClearEvent and NtResetEvent, but the first works faster\n(see \nNtResetEvent).\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCreateEvent\nNtOpenEvent\nNtResetEvent\nNtSetEvent\n"
      },
      "NtResetEvent": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtResetEvent(\n  IN HANDLE               EventHandle,\n  OUT PLONG               PreviousState OPTIONAL );\n",
            "description": "\nEventHandle HANDLE to Event\nObject opened with EVENT_MODIFY_STATE access.\nPreviousState Optional pointer to state\nof event before function call. Difference between\nNtResetEvent and NtClearEvent is the\nfirst one can return state of event before call.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtClearEvent\nNtCreateEvent\nNtOpenEvent\nNtQueryEvent\nNtSetEvent\n"
      },
      "NtPulseEvent": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtPulseEvent(\n  IN HANDLE               EventHandle,\n  OUT PLONG               PreviousState OPTIONAL );\n",
            "description": "\nEventHandle HANDLE to Event\nObject opened with EVENT_MODIFY_STATE access.\nPreviousState State of event before\ncall.\nFunction sets event to signaled state, releases all (or one -\ndependly of \nEVENT_TYPE) waiting threads, and resets event to non-signaled\nstate. If they're no waiting threads, NtPulseEvent\njust clear event state.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nEVENT_TYPE\nNtClearEvent\nNtCreateEvent\nNtOpenEvent\nNtResetEvent\nNtSetEvent\n"
      },
      "EVENT_INFORMATION_CLASS": {
            "code": "\ntypedef enum _EVENT_INFORMATION_CLASS {\n    EventBasicInformation\n} EVENT_INFORMATION_CLASS, *PEVENT_INFORMATION_CLASS;\n",
            "description": "\nThis enumeration type is used with NtQueryEvent. There're no corresponding\nfunction to set event information. Currently only one information\nclass is defined:\nEventBasicInformation See EVENT_BASIC_INFORMATION for\ndetails.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nEVENT_BASIC_INFORMATION\nNtQueryEvent\n"
      },
      "EVENT_TYPE": {
            "code": "\ntypedef enum _EVENT_TYPE {\n    NotificationEvent,\n    SynchronizationEvent\n} EVENT_TYPE, *PEVENT_TYPE;\n",
            "description": "\nThere are two Event types in WinNT:\nNotificationEvent Known also as\nmanual-reset event. Caller decide about state of event. You can use\nNtClearEvent or NtResetEvent to put Event Object into\nnon-signaled state.\nSynchronizationEvent Known as\nauto-reset event. This type automatically change his state to\nnon-signaled after releasing any (but only one) waiting thread.\nTo check what type of event do you have, use NtQueryEvent.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtClearEvent\nNtCreateEvent\nNtQueryEvent\nNtResetEvent\n"
      },
      "NtSetEventBoostPriority": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtSetEventBoostPriority(\n  IN HANDLE               EventHandle );\n",
            "description": "\nFunction NtSetEventPriorityBoost was added in\nWindows XP system. Has the same functionality as \nNtSetEvent, but thread that is waiting on specified\nEvent will be executed immediatelly after context switch,\nregardless of waiting thread's priority.\nEventHandle HANDLE to previously\ncreated or opened Event object. Note that Event has to be\ncreated with \nEVENT_TYPE set to SynchronizationEvent (automatic\nreset), in other cases function will return with error.\nSupported on system versions:\nWin XP/2003\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nEVENT_TYPE\nNtCreateEvent\nNtOpenEvent\nNtSetEvent\n"
      },
      "NtOpenEvent": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtOpenEvent(\n  OUT PHANDLE             EventHandle,\n  IN ACCESS_MASK          DesiredAccess,\n  IN POBJECT_ATTRIBUTES   ObjectAttributes );\n",
            "description": "\nEventHandle Result of call -\nHANDLE to Event Object.\nDesiredAccess See NtCreateEvent for possible access rights.\nObjectAttributes Must contain valid\nEvent Object name, in NT Objects Namespace.\nOnly named events can be opened by this function call.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCreateEvent\n"
      },
      "NtReleaseMutant": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtReleaseMutant(\n  IN HANDLE               MutantHandle,\n  OUT PLONG               PreviousCount OPTIONAL );\n",
            "description": "\nPreviousCount\nInternal mutant counter state before call NtReleaseMutant.\n"
      },
      "NtCreateMutant": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtCreateMutant(\n  OUT PHANDLE             MutantHandle,\n  IN ACCESS_MASK          DesiredAccess,\n  IN POBJECT_ATTRIBUTES   ObjectAttributes OPTIONAL,\n  IN BOOLEAN              InitialOwner );\n",
            "description": "\nMutantHandle\nResult of function call - handle to newly created Mutant object.\n"
      },
      "NtOpenMutant": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtOpenMutant(\n  OUT PHANDLE             MutantHandle,\n  IN ACCESS_MASK          DesiredAccess,\n  IN POBJECT_ATTRIBUTES   ObjectAttributes );\n",
            "description": "\nDesiredAccess\nSee &lt;WinNT.h&gt; or &lt;WinBase.h&gt; for possible Mutant access rights.\n"
      },
      "NtQueryMutant": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtQueryMutant(\n  IN HANDLE               MutantHandle,\n  IN MUTANT_INFORMATION_CLASS MutantInformationClass,\n  OUT PVOID               MutantInformation,\n  IN ULONG                MutantInformationLength,\n  OUT PULONG              ResultLength OPTIONAL );\n",
            "description": "\nMutantHandle\nHandle to Mutant object.\n"
      },
      "PROCESS_WS_WATCH_INFORMATION": {
            "code": "\ntypedef struct _PROCESS_WS_WATCH_INFORMATION {\n  PVOID                   FaultingPc;\n  PVOID                   FaultingVa;\n} PROCESS_WS_WATCH_INFORMATION, *PPROCESS_WS_WATCH_INFORMATION;\n",
            "description": "\nFaultingPc \nFaultingVa \nSupported on system versions:\nNT 4.0,Win 2000,Win XP/2003\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCreateProcess\nNtOpenProcess\nNtQueryInformationProcess\nPROCESS_INFORMATION_CLASS\n"
      },
      "NtQueryInformationProcess": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtQueryInformationProcess(\n  IN HANDLE               ProcessHandle,\n  IN PROCESS_INFORMATION_CLASS ProcessInformationClass,\n  OUT PVOID               ProcessInformation,\n  IN ULONG                ProcessInformationLength,\n  OUT PULONG              ReturnLength );\n",
            "description": "\nProcessHandle\nHandle to process opened with PROCESS_QUERY_INFORMATION access.\n"
      },
      "POOLED_USAGE_AND_LIMITS": {
            "code": "\ntypedef struct _POOLED_USAGE_AND_LIMITS {\n  ULONG                   PeakPagedPoolUsage;\n  ULONG                   PagedPoolUsage;\n  ULONG                   PagedPoolLimit;\n  ULONG                   PeakNonPagedPoolUsage;\n  ULONG                   NonPagedPoolUsage;\n  ULONG                   NonPagedPoolLimit;\n  ULONG                   PeakPagefileUsage;\n  ULONG                   PagefileUsage;\n  ULONG                   PagefileLimit;\n} POOLED_USAGE_AND_LIMITS, *PPOOLED_USAGE_AND_LIMITS;\n",
            "description": "\nPeakPagedPoolUsage \nPagedPoolUsage \nPagedPoolLimit \nPeakNonPagedPoolUsage \nNonPagedPoolUsage \nNonPagedPoolLimit \nPeakPagefileUsage \nPagefileUsage \nPagefileLimit \nSupported on system versions:\nNT 4.0,Win 2000,Win XP/2003\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCreateProcess\nNtOpenProcess\nNtQueryInformationProcess\nPROCESS_INFORMATION_CLASS\n"
      },
      "NtTerminateProcess": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtTerminateProcess(\n  IN HANDLE               ProcessHandle OPTIONAL,\n  IN NTSTATUS             ExitStatus );\n",
            "description": "\nProcessHandle\n"
      },
      "PROCESS_ACCESS_TOKEN": {
            "code": "\ntypedef struct _PROCESS_ACCESS_TOKEN {\n  HANDLE                  Token;\n  HANDLE                  Thread;\n} PROCESS_ACCESS_TOKEN, *PPROCESS_ACCESS_TOKEN;\n",
            "description": "\nToken \nThread \nSupported on system versions:\nNT 4.0,Win 2000,Win XP/2003\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtCreateProcess\nNtOpenProcess\nNtSetInformationProcess\nPROCESS_INFORMATION_CLASS\n"
      },
      "NtOpenProcess": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtOpenProcess(\n  OUT PHANDLE             ProcessHandle,\n  IN ACCESS_MASK          AccessMask,\n  IN POBJECT_ATTRIBUTES   ObjectAttributes,\n  IN PCLIENT_ID           ClientId );\n",
            "description": "\nAccessMask\n     \n"
      },
      "PEB": {
            "code": "\ntypedef struct _PEB {\n  BOOLEAN                 InheritedAddressSpace;\n  BOOLEAN                 ReadImageFileExecOptions;\n  BOOLEAN                 BeingDebugged;\n  BOOLEAN                 Spare;\n  HANDLE                  Mutant;\n  PVOID                   ImageBaseAddress;\n  PPEB_LDR_DATA           LoaderData;\n  PRTL_USER_PROCESS_PARAMETERS ProcessParameters;\n  PVOID                   SubSystemData;\n  PVOID                   ProcessHeap;\n  PVOID                   FastPebLock;\n  PPEBLOCKROUTINE         FastPebLockRoutine;\n  PPEBLOCKROUTINE         FastPebUnlockRoutine;\n  ULONG                   EnvironmentUpdateCount;\n  PPVOID                  KernelCallbackTable;\n  PVOID                   EventLogSection;\n  PVOID                   EventLog;\n  PPEB_FREE_BLOCK         FreeList;\n  ULONG                   TlsExpansionCounter;\n  PVOID                   TlsBitmap;\n  ULONG                   TlsBitmapBits[0x2];\n  PVOID                   ReadOnlySharedMemoryBase;\n  PVOID                   ReadOnlySharedMemoryHeap;\n  PPVOID                  ReadOnlyStaticServerData;\n  PVOID                   AnsiCodePageData;\n  PVOID                   OemCodePageData;\n  PVOID                   UnicodeCaseTableData;\n  ULONG                   NumberOfProcessors;\n  ULONG                   NtGlobalFlag;\n  BYTE                    Spare2[0x4];\n  LARGE_INTEGER           CriticalSectionTimeout;\n  ULONG                   HeapSegmentReserve;\n  ULONG                   HeapSegmentCommit;\n  ULONG                   HeapDeCommitTotalFreeThreshold;\n  ULONG                   HeapDeCommitFreeBlockThreshold;\n  ULONG                   NumberOfHeaps;\n  ULONG                   MaximumNumberOfHeaps;\n  PPVOID                  *ProcessHeaps;\n  PVOID                   GdiSharedHandleTable;\n  PVOID                   ProcessStarterHelper;\n  PVOID                   GdiDCAttributeList;\n  PVOID                   LoaderLock;\n  ULONG                   OSMajorVersion;\n  ULONG                   OSMinorVersion;\n  ULONG                   OSBuildNumber;\n  ULONG                   OSPlatformId;\n  ULONG                   ImageSubSystem;\n  ULONG                   ImageSubSystemMajorVersion;\n  ULONG                   ImageSubSystemMinorVersion;\n  ULONG                   GdiHandleBuffer[0x22];\n  ULONG                   PostProcessInitRoutine;\n  ULONG                   TlsExpansionBitmap;\n  BYTE                    TlsExpansionBitmapBits[0x80];\n  ULONG                   SessionId;\n} PEB, *PPEB;\n",
            "description": "\nStructure PEB (Process Enviroment Block)\ncontains all User-Mode parameters associated by system with\ncurrent process.\nInheritedAddressSpace \nReadImageFileExecOptions \nBeingDebugged \nSpare \nMutant \nImageBaseAddress Address of executable\nimage in process' memory.\nLoaderData Pointer to PEB_LDR_DATA structure\ncontains information filled by Loader.\nProcessParameters Pointer to RTL_USER_PROCESS_PARAMETERS\nstructure.\nSubSystemData \nProcessHeap Address of process' first\nheap allocated by Loader.\nFastPebLock Parameter for\nPEBLOCKROUTINE (see below).\nFastPebLockRoutine Address of\nfast-locking routine for PEB. Definition of routine\nis:\ntypedef void\n(*PPEBLOCKROUTINE)(\nPVOID PebLock\n);\nFastPebUnlockRoutine PEB\nfast-unlock routine.\nEnvironmentUpdateCount Counter of\nprocess environment updates.\nKernelCallbackTable \nEventLogSection \nEventLog \nFreeList \nTlsExpansionCounter \nTlsBitmap \nTlsBitmapBits[0x2] \nReadOnlySharedMemoryBase \nReadOnlySharedMemoryHeap \nReadOnlyStaticServerData \nAnsiCodePageData \nOemCodePageData \nUnicodeCaseTableData \nNumberOfProcessors \nNtGlobalFlag \nSpare2[0x4] \nCriticalSectionTimeout \nHeapSegmentReserve \nHeapSegmentCommit \nHeapDeCommitTotalFreeThreshold \nHeapDeCommitFreeBlockThreshold \nNumberOfHeaps \nMaximumNumberOfHeaps \n*ProcessHeaps \nGdiSharedHandleTable \nProcessStarterHelper \nGdiDCAttributeList \nLoaderLock \nOSMajorVersion \nOSMinorVersion \nOSBuildNumber \nOSPlatformId \nImageSubSystem \nImageSubSystemMajorVersion \nImageSubSystemMinorVersion \nGdiHandleBuffer[0x22] \nPostProcessInitRoutine \nTlsExpansionBitmap \nTlsExpansionBitmapBits[0x80] \nSessionId \n\nDocumented by:\nReactos\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtQueryInformationProcess\nPEB_FREE_BLOCK\nPEB_LDR_DATA\nPROCESS_BASIC_INFORMATION\nRTL_USER_PROCESS_PARAMETERS\nTEB\n"
      },
      "NtCreateProcess": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtCreateProcess(\n  OUT PHANDLE           ProcessHandle,\n  IN ACCESS_MASK        DesiredAccess,\n  IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,\n  IN HANDLE             ParentProcess,\n  IN BOOLEAN            InheritObjectTable,\n  IN HANDLE             SectionHandle OPTIONAL,\n  IN HANDLE             DebugPort OPTIONAL,\n  IN HANDLE             ExceptionPort OPTIONAL ); \n",
            "description": "\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nPsCreateSystemProcess\nNtTerminateProcess\nNtOpenProcess\n"
      },
      "NtFlushInstructionCache": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtFlushInstructionCache(\n  IN HANDLE               ProcessHandle,\n  IN PVOID                BaseAddress,\n  IN ULONG                NumberOfBytesToFlush );\n",
            "description": "\nFunction NtFlushInstructionCache empties execution\ncache for specified region of code. It shoult be used always after\nmodification of process's executable memory (for example when\nNtLdr fills imported function's entries).\nProcessHandle HANDLE to Process\nObject.\nBaseAddress Starting memory address to\nflush.\nNumberOfBytesToFlush Length of flushed\nmemory block.\n\nDocumented by:\nReactos\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtOpenProcess\n"
      },
      "PEB_FREE_BLOCK": {
            "code": "\ntypedef struct _PEB_FREE_BLOCK {\n  PEB_FREE_BLOCK          *Next;\n  ULONG                   Size;\n} PEB_FREE_BLOCK, *PPEB_FREE_BLOCK;\n",
            "description": "\nStructure PEB_FREE_BLOCK is used internally in\nPEB (Process Enviroment Block)\nstructure for describe free blocks in memory allocated for PEB.\n*Next Pointer to next free block.\nSize Size of block, in bytes.\n\nDocumented by:\nReactos\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nPEB\n"
      },
      "NtSetInformationProcess": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtSetInformationProcess(\n  IN HANDLE               ProcessHandle,\n  IN PROCESS_INFORMATION_CLASS ProcessInformationClass,\n  IN PVOID                ProcessInformation,\n  IN ULONG                ProcessInformationLength );\n",
            "description": "\nProcessHandle\nHandle to process opened with PROCESS_SET_INFORMATION access.\n"
      },
      "PROCESS_INFORMATION_CLASS": {
            "code": "\ntypedef enum _PROCESS_INFORMATION_CLASS {\n    ProcessBasicInformation,\n    ProcessQuotaLimits,\n    ProcessIoCounters,\n    ProcessVmCounters,\n    ProcessTimes,\n    ProcessBasePriority,\n    ProcessRaisePriority,\n    ProcessDebugPort,\n    ProcessExceptionPort,\n    ProcessAccessToken,\n    ProcessLdtInformation,\n    ProcessLdtSize,\n    ProcessDefaultHardErrorMode,\n    ProcessIoPortHandlers,\n    ProcessPooledUsageAndLimits,\n    ProcessWorkingSetWatch,\n    ProcessUserModeIOPL,\n    ProcessEnableAlignmentFaultFixup,\n    ProcessPriorityClass,\n    ProcessWx86Information,\n    ProcessHandleCount,\n    ProcessAffinityMask,\n    ProcessPriorityBoost,\n    MaxProcessInfoClass\n} PROCESS_INFORMATION_CLASS, *PPROCESS_INFORMATION_CLASS;\n",
            "description": "\nEnumeration type PROCESS_INFORMATION_CLASS is used in\na calls to \nNtQueryInformationProcess and \nNtSetInformationProcess. Structures for sending or receiving\ndata are accessable below, separatelly for target information\nclass.\nProcessBasicInformation\nAction\n: Query\nBuffer size\n: 0x018\nStructure\n: PROCESS_BASIC_INFORMATION\nProcessQuotaLimits\nAction\n: Query, Set\nBuffer size\n: 0x020\nStructure\n: QUOTA_LIMITS\nProcessIoCounters\nAction\n: Query\nBuffer size\n: ???\nStructure\n: IO_COUNTERS\nProcessVmCounters\nAction\n: Query\nBuffer size\n: 0x02C\nStructure\n: VM_COUNTERS\nProcessTimes\nAction\n: Query\nBuffer size\n: 0x020\nStructure\n: KERNEL_USER_TIMES\nProcessBasePriority\nAction\n: Set\nBuffer size\n: 0x004\nBuffer\n: KPRIORITY\nComment\n: Sets process' Base Priority.\nProcessRaisePriority\nAction\n: Set\nBuffer size\n: 0x004\nBuffer\n: KPRIORITY\nComment\n: Sets process' Raise Priority.\nProcessDebugPort\nAction\n: Query, Set\nBuffer size\n: 0x004\nBuffer\n: HANDLE\nComment\n: Queries and sets process' Debug Port. See also NtCreatePort.\nProcessExceptionPort\nAction\n: Set\nBuffer size\n: 0x004\nBuffer\n: HANDLE\nComment\n: Sets process' Exception Port. See also NtCreatePort.\nProcessAccessToken\nAction\n: Set\nBuffer size\n: 0x008\nStructure\n: PROCESS_ACCESS_TOKEN\nProcessLdtInformation\nAction\n: Query\nBuffer size\n: ???\nStructure\n: LDT_ENTRY\nAction\n: Set\nBuffer size\n: 0x010\nStructure\n: LDT_ENTRY\nProcessLdtSize\nAction\n: Set\nBuffer size\n: 0x004\nBuffer\n: ULONG\nComment\n: Sets process' Local Description Table size. See also NtSetLdtEntries function.\nProcessDefaultHardErrorMode\nAction\n: Query, Set\nBuffer size\n: 0x004\nBuffer\n: ULONG\nComment\n: ???\nProcessIoPortHandlers\nAction\n: Set\nBuffer size\n: ???\nStructure\n: ???\nProcessPooledUsageAndLimits\nAction\n: Query\nBuffer size\n: 0x024\nStructure\n: POOLED_USAGE_AND_LIMITS\nProcessWorkingSetWatch\nAction\n: Query\nBuffer size\n: ???\nStructure\n: PROCESS_WS_WATCH_INFORMATION\nAction\n: Set\nBuffer size\n: ???\nStructure\n:\nProcessUserModeIOPL\nAction\n: Set\nBuffer size\n: ???\nStructure\n:\nProcessEnableAlignmentFaultFixup\nAction\n: Set\nBuffer size\n: 0x001\nBuffer\n: BOOLEAN\nComment\n: If set, enables automatic fixup of memory dissaligments.\nProcessPriorityClass\nAction\n: Set\nBuffer size\n: 0x002\nBuffer\n: WORD\nComment\n: Sets process' Priority Class.\nProcessWx86Information\nAction\n: Query\nBuffer size\n: 0x004\nBuffer\n: ULONG\nComment\n: ???\nProcessHandleCount\nAction\n: Query\nBuffer size\n: 0x004\nBuffer\n: ULONG\nComment\n: Retrives Handle's count for process.\nProcessAffinityMask\nAction\n: Set\nBuffer size\n: 0x0\nBuffer\n: KAFFINITY\nComment\n: Sets process' Affinity Mask.\nProcessPriorityBoost\nAction\n: Query, Set\nBuffer size\n: 0x004\nBuffer\n: KPRIORITY\nComment\n: Queries and sets process' Priority Boost.\n\nDocumented by:\nTomasz Nowak\nSven B. Schreiber\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtQueryInformationProcess\nNtSetInformationProcess\n"
      },
      "LdrShutdownThread": {
            "code": "\nNTSYSAPI \nVOID\nNTAPI\nLdrShutdownThread();\n",
            "description": "\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nLdrShutdownProcess\n"
      },
      "LdrGetProcedureAddress": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nLdrGetProcedureAddress(\n  IN HMODULE              ModuleHandle,\n  IN PANSI_STRING         FunctionName OPTIONAL,\n  IN WORD                 Oridinal OPTIONAL,\n  OUT PVOID               *FunctionAddress );\n",
            "description": "\nFunctionName\n"
      },
      "RtlCreateUserProcess": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nRtlCreateUserProcess(\n  IN PUNICODE_STRING      ImagePath,\n  IN ULONG                ObjectAttributes,\n  IN OUT PRTL_USER_PROCESS_PARAMETERS ProcessParameters,\n  IN PSECURITY_DESCRIPTOR ProcessSecurityDescriptor OPTIONAL,\n  IN PSECURITY_DESCRIPTOR ThreadSecurityDescriptor OPTIONAL,\n  IN HANDLE               ParentProcess,\n  IN BOOLEAN              InheritHandles,\n  IN HANDLE               DebugPort OPTIONAL,\n  IN HANDLE               ExceptionPort OPTIONAL,\n  OUT PRTL_USER_PROCESS_INFORMATION ProcessInformation );\n",
            "description": "\nImagePath\nFull path to executable image, in NT format (ex: \"\\??\\C:\\WinNT\\SYSTEM32\\cmd.exe\").\n"
      },
      "RtlImageNtHeader": {
            "code": "\nNTSYSAPI \nPIMAGE_NT_HEADERS\nNTAPI\nRtlImageNtHeader(\n  IN PVOID                ModuleAddress );\n",
            "description": "\nModuleAddress\n"
      },
      "LdrShutdownProcess": {
            "code": "\nNTSYSAPI \nVOID\nNTAPI\nLdrShutdownProcess();\n",
            "description": "\nKernel32.dll use this after call to NtTerminateProcess.\n"
      },
      "RtlCreateUserThread": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nRtlCreateUserThread(\n  IN HANDLE               ProcessHandle,\n  IN PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL,\n  IN BOOLEAN              CreateSuspended,\n  IN ULONG                StackZeroBits,\n  IN OUT PULONG           StackReserved,\n  IN OUT PULONG           StackCommit,\n  IN PVOID                StartAddress,\n  IN PVOID                StartParameter OPTIONAL,\n  OUT PHANDLE             ThreadHandle,\n  OUT PCLIENT_ID          ClientID );\n",
            "description": "\nStackZeroBits\nHow many older bits must be clear while allocating thread stack. See INITIAL_TEB.\n"
      },
      "LdrLoadDll": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nLdrLoadDll(\n  IN PWCHAR               PathToFile OPTIONAL,\n  IN ULONG                Flags OPTIONAL,\n  IN PUNICODE_STRING      ModuleFileName,\n  OUT PHANDLE             ModuleHandle );\n",
            "description": "\nFlags\n"
      },
      "NtLoadDriver": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtLoadDriver(\n  IN PUNICODE_STRING DriverServiceName );\n",
            "description": "\nDriverServiceName\nRegistry path in system format. Path must begin\nwith \"\\\\registry\\\\machine\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\...\"\nwhere \"...\" is driver symbolic name.\nKey must have at least 2 values:\n\"ImagePath\" System path to file, in\nUNICODE format\n\"Type\" Set to 1.\nRequirements:\n\nLibrary: ntdll.lib\nPrivilege:\nSeLoadDriverPrivilege\n\nSee also:\nNtUnloadDriver\n"
      },
      "LdrGetDllHandle": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nLdrGetDllHandle(\n  IN PWORD                pwPath OPTIONAL,\n  IN PVOID                Unused OPTIONAL,\n  IN PUNICODE_STRING      ModuleFileName,\n  OUT PHANDLE             pHModule );\n",
            "description": "\npwPath\n"
      },
      "NtUnloadDriver": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtUnloadDriver(\n  IN PUNICODE_STRING DriverServiceName );\n",
            "description": "\nDriverServiceName\nRegistry path in system format.\nRequirements:\n\nLibrary: ntdll.lib\nPrivilege:\nSeLoadDriverPrivilege\n\nSee also:\nNtLoadDriver\n"
      },
      "RtlImageRvaToVa": {
            "code": "\nNTSYSAPI \nPVOID\nNTAPI\nRtlImageRvaToVa(\n  IN PIMAGE_NT_HEADERS    NtHeaders,\n  IN PVOID                ModuleBase,\n  IN ULONG                Rva,\n  IN OUT PIMAGE_SECTION_HEADER pLastSection OPTIONAL );\n",
            "description": "\n"
      },
      "LdrQueryProcessModuleInformation": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nLdrQueryProcessModuleInformation(\n  OUT PSYSTEM_MODULE_INFORMATION SystemModuleInformationBuffer,\n  IN ULONG                BufferSize,\n  OUT PULONG              RequiredSize OPTIONAL );  \n",
            "description": "\nUse for enumerate modules loaded with current\nprocess.\n"
      },
      "LdrUnloadDll": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nLdrUnloadDll(\n  IN HANDLE               ModuleHandle );\n",
            "description": "\nModuleHandle\n"
      },
      "RtlSetCurrentEnvironment": {
            "code": "\nNTSYSAPI \nVOID\nNTAPI\nRtlSetCurrentEnvironment(\n  IN PVOID                NewEnvironment,\n  OUT PVOID               *OldEnvironment OPTIONAL );\n",
            "description": "\n"
      },
      "NtQuerySystemEnvironmentValue": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtQuerySystemEnvironmentValue(\n  IN PUNICODE_STRING      VariableName,\n  OUT PWCHAR              Value,\n  IN ULONG                ValueBufferLength,\n  OUT PULONG              RequiredLength OPTIONAL );\n",
            "description": "\nSeems not works on NT 4.0 SP6. Control Panel applet query and set System Environment values by Rtl...Environment functions or directly by registry.\n"
      },
      "RtlExpandEnvironmentStrings_U": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nRtlExpandEnvironmentStrings_U(\n  IN PVOID                Environment OPTIONAL,\n  IN PUNICODE_STRING      SourceString,\n  OUT PUNICODE_STRING     DestinationString,\n  OUT PULONG              DestinationBufferLength OPTIONAL );\n",
            "description": "\nEnvironment\nPointer to environment block.\n"
      },
      "RtlSetEnvironmentVariable": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nRtlSetEnvironmentVariable(\n  IN OUT PVOID            *Environment OPTIONAL,\n  IN PUNICODE_STRING      VariableName,\n  IN PUNICODE_STRING      VariableValue );\n",
            "description": "\n*Environment\nIf Environment is NULL, current environment block is used. \nIf Environment point to NULL value, new environment block is allocated and variable is set in new block.\nIf you can set variable in not currently set env. block, set as Environment pointer to that block.\n"
      },
      "RtlDestroyEnvironment": {
            "code": "\nNTSYSAPI \nVOID\nNTAPI\nRtlDestroyEnvironment(\n  IN PVOID                Environment );\n",
            "description": "\n"
      },
      "RtlQueryEnvironmentVariable_U": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nRtlQueryEnvironmentVariable_U(\n  IN PVOID                Environment OPTIONAL,\n  IN PUNICODE_STRING      VariableName,\n  OUT PUNICODE_STRING     VariableValue );\n",
            "description": "\nEnvironment\nPointer to environment block. If NULL, current environment is used.\n"
      },
      "RtlCreateEnvironment": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nRtlCreateEnvironment(\n  IN BOOLEAN              Inherit,\n  OUT PVOID               *Environment );\n",
            "description": "\nInherit\nIf set, newly created environment are similar to caller's environment.\n"
      },
      "NtSetSystemEnvironmentValue": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtSetSystemEnvironmentValue(\n  IN PUNICODE_STRING      VariableName,\n  IN PUNICODE_STRING      Value );\n",
            "description": "\nSeems not works on NT 4.0 SP6...\n"
      },
      "HARDERROR_RESPONSE_OPTION": {
            "code": "\ntypedef enum _HARDERROR_RESPONSE_OPTION {\n    OptionAbortRetryIgnore,\n    OptionOk,\n    OptionOkCancel,\n    OptionRetryCancel,\n    OptionYesNo,\n    OptionYesNoCancel,\n    OptionShutdownSystem\n} HARDERROR_RESPONSE_OPTION, *PHARDERROR_RESPONSE_OPTION;\n",
            "description": "\nThis enumerated type is used for specify type of MessageBox\nwith error description in a call to NtRaiseHardError.\nOptionAbortRetryIgnore Visible buttons:\nABORT, RETRY, IGNORE\nOptionOk Visible buttons:\nOK\nOptionOkCancel Visible buttons:\nOK, CANCEL\nOptionRetryCancel Visible buttons:\nRETRY, CANCEL\nOptionYesNo Visible buttons:\nYES, NO\nOptionYesNoCancel Visible buttons:\nYES, NO, CANCEL\nOptionShutdownSystem - ???\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nHARDERROR_RESPONSE\nNtRaiseHardError\n"
      },
      "NtRaiseException": {
            "code": "\nNTSYSAPI\nNTSTATUS\nNTAPI\nNtRaiseException(\n  IN PEXCEPTION_RECORD    ExceptionRecord,\n  IN PCONTEXT             ThreadContext,\n  IN BOOLEAN              HandleException );\n",
            "description": "\nFunction NtRaiseException is typically used inside\nKiUserExceptionDispatcher\nfunction for inform system about exception in current process.\nExceptionRecord Pointer to\nEXCEPTION_RECORD structure containing typical\ninformation about error.\nThreadContext Pointer to\nCONTEXT structure.\nHandleException If not set, calling\nprocess is killed. If set, system tries to execute actually enabled\nException Handler procedure with parameters specified aa\nExceptionRecord and ThreadContext.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nKiUserExceptionDispatcher\nNtGetContextThread\nNtRaiseHardError\n"
      },
      "HARDERROR_RESPONSE": {
            "code": "\ntypedef enum _HARDERROR_RESPONSE {\n    ResponseReturnToCaller,\n    ResponseNotHandled,\n    ResponseAbort,\n    ResponseCancel,\n    ResponseIgnore,\n    ResponseNo,\n    ResponseOk,\n    ResponseRetry,\n    ResponseYes\n} HARDERROR_RESPONSE, *PHARDERROR_RESPONSE;\n",
            "description": "\nThis enumeration type is used as a result of call NtRaiseHardError and specify user's\nresponse for error message.\nResponseReturnToCaller - ???\nResponseNotHandled - ???\nResponseAbort ABORT button was\npressed.\nResponseCancel CANCEL button was\npressed.\nResponseIgnore IGNORE button was\npressed.\nResponseNo NO button was\npressed.\nResponseOk OK button was\npressed.\nResponseRetry RETRY button was\npressed.\nResponseYes YES button was\npressed.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nHARDERROR_RESPONSE_OPTION\nNtRaiseHardError\n"
      },
      "HARDERROR_MSG": {
            "code": "\ntypedef struct _HARDERROR_MSG {\n  LPC_MESSAGE             LpcMessageHeader;\n  NTSTATUS                ErrorStatus;\n  LARGE_INTEGER           ErrorTime;\n  HARDERROR_RESPONSE_OPTION ResponseOption;\n  HARDERROR_RESPONSE      Response;\n  ULONG                   NumberOfParameters;\n  PVOID                   UnicodeStringParameterMask;\n  ULONG                   Parameters[MAXIMUM_HARDERROR_PARAMETERS];\n} HARDERROR_MSG, *PHARDERROR_MSG;\n",
            "description": "\nStructure HARDERROR_MSG is send to LPC server\nin a result of call NtRaiseHardError.\nMost of stucture's members are the same as parameters specified in\nthis call.\nLpcMessageHeader Message header - see\nLPC_MESSAGE description.\nErrorStatus Error code.\nErrorTime Time when error was\nsignaled.\nResponseOption See \nHARDERROR_RESPONSE_OPTION for possible values.\nResponse See HARDERROR_RESPONSE\nfor possible values.\nNumberOfParameters Number of parameters\nin Parameters array. Maximum\nparameters number is defined as:\n#define\nMAXIMUM_HARDERROR_PARAMETERS 4\nUnicodeStringParameterMask Pointer to\nUNICODE_STRING in port's client address space\nParameters[MAXIMUM_HARDERROR_PARAMETERS]\nArray of DWORD parameters.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nHARDERROR_RESPONSE\nHARDERROR_RESPONSE_OPTION\nNtRaiseHardError\nNtSetDefaultHardErrorPort\n"
      },
      "NtRaiseHardError": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtRaiseHardError(\n  IN NTSTATUS             ErrorStatus,\n  IN ULONG                NumberOfParameters,\n  IN PUNICODE_STRING      UnicodeStringParameterMask OPTIONAL,\n  IN PVOID                *Parameters,\n  IN HARDERROR_RESPONSE_OPTION ResponseOption,\n  OUT PHARDERROR_RESPONSE Response );\n",
            "description": "\nThis function sends HARDERROR_MSG\nLPC message to listener (typically CSRSS.EXE). See\nNtSetDefaultHardErrorPort for more information.\nErrorStatus Error code.\nNumberOfParameters Number of optional\nparameters in Parameters\narray.\nUnicodeStringParameterMask Optional\nstring parameter (can be only one per error code).\n*Parameters Array of DWORD\nparameters for use in error message string.\nResponseOption See \nHARDERROR_RESPONSE_OPTION for possible values description.\nResponse Pointer to HARDERROR_RESPONSE\nenumeration.\nNtRaiseHardError is easy way to display message in\nGUI without loading Win32 API libraries.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nHARDERROR_MSG\nHARDERROR_RESPONSE\nHARDERROR_RESPONSE_OPTION\nNtSetDefaultHardErrorPort\n"
      },
      "NtDisplayString": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtDisplayString(\n  IN PUNICODE_STRING      String );\n",
            "description": "\nFunction NtDisplayString display specified string in\ntext-mode (typically: blue screen).\nWarning: Trying to display string without\npreviously switch to text-mode results as system hang.\nString Pointer to UNICODE_STRING\ncontains string to display. Some basic control characters are\nimplemented (like CR, LF).\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\nPrivilege: SE_TCB_PRIVILEGE\n\nSee also:\n"
      },
      "NtSetDefaultHardErrorPort": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtSetDefaultHardErrorPort(\n  IN HANDLE               PortHandle );\n",
            "description": "\nNtSetDefaultHardErrorPort is typically called only\nonce. After call, kernel set BOOLEAN flag named\n_ExReadyForErrors to TRUE, and all other tries to\nchange default port are broken with STATUS_UNSUCCESSFUL\nerror code.\nPortHandle HANDLE to named Port\nObject.\nListener of default HardError port receive HARDERROR_MSG\nLPC messages when any process call NtRaiseHardError\nfunction.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\nPrivileges: SE_TCB_PRIVILEGE\n\nSee also:\nHARDERROR_MSG\nNtRaiseHardError\n"
      },
      "NtSystemDebugControl": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nNtSystemDebugControl(\n  IN SYSDBG_COMMAND       Command,\n  IN PVOID                InputBuffer OPTIONAL,\n  IN ULONG                InputBufferLength,\n  OUT PVOID               OutputBuffer OPTIONAL,\n  IN ULONG                OutputBufferLength,\n  OUT PULONG              ReturnLength OPTIONAL );\n",
            "description": "\nFunction NtSystemDebugControl is used by some\nlow-level debuggers written by Microsoft and avaiable\ntypically in DDK.\nCommand Command request for system.\nCommand's codes are avaiable in enumeration type SYSDBG_COMMAND.\nInputBuffer User's allocated buffer\nwith input data.\nInputBufferLength Length of\nInputBuffer, in bytes.\nOutputBuffer User's allocated buffer\nfor output data.\nOutputBufferLength Length of\nOutputBuffer, in bytes.\nReturnLength Pointer to ULONG\nvalue receiving required size of OutputBuffer.\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nSYSDBG_COMMAND\n"
      },
      "DbgPrint": {
            "code": "\nNTSYSAPI \nNTSTATUS\nNTAPI\nDbgPrint(\n  IN LPCSTR               Format,\n  ... );\n",
            "description": "\nFunction works like a normal C printf routine, but result is streamed to debug output.\n"
      },
      "RtlGetCallersAddress": {
            "code": "\nNTSYSAPI \nPVOID\nNTAPI\nRtlGetCallersAddress(\n  OUT PVOID               *CallersAddress,\n  OUT PVOID               *CallersCaller );\n",
            "description": "\nRoutine RtlGetCallersAddress is usefull in program\ndebugging or exceptions control. It returns address of calling\ninstruction.\nCallersAddress Returns address in body\nof function that call RtlGetCallersAddress.\nCallersCaller Returns address in\nfunction's calling function that call\nRtlGetCallersAddress body.\nSupported on system versions:\nNT 4.0,Win 2000,Win XP/2003\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nRtlCaptureStackBackTrace\n"
      },
      "SYSDBG_COMMAND": {
            "code": "\ntypedef enum _SYSDBG_COMMAND {\n    SysDbgQueryModuleInformation=1,\n    SysDbgQueryTraceInformation,\n    SysDbgSetTracepoint,\n    SysDbgSetSpecialCall,\n    SysDbgClearSpecialCalls,\n    SysDbgQuerySpecialCalls\n} SYSDBG_COMMAND, *PSYSDBG_COMMAND;\n",
            "description": "\nEnumeration type SYSDBG_COMMAND is used as a command\nnumber in a call to NtSystemDebugControl function.\nSysDbgQueryModuleInformation\n(?)\nSysDbgQueryTraceInformation\n(?)\nSysDbgSetTracepoint\n(?)\nSysDbgSetSpecialCall\n(?)\nSysDbgClearSpecialCalls\n(?)\nSysDbgQuerySpecialCalls\n(?)\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nNtSystemDebugControl\n"
      },
      "RtlCaptureStackBackTrace": {
            "code": "\nNTSYSAPI \nUSHORT\nNTAPI\nRtlCaptureStackBackTrace(\n  IN ULONG                FramesToSkip,\n  IN ULONG                FramesToCapture,\n  OUT PVOID               *BackTrace,\n  OUT PULONG              BackTraceHash );\n",
            "description": "\nFunction RtlCaptureStackBackTrace is usefull for\ndebugging and analysing problems by making complete trace of\ncalling functions by processing stack.\nFramesToSkip How many stack entries\nshould be skiped.\nFramesToCapture Length of BackTrace buffer array.\nBackTrace Array of caller's\naddresses.\nBackTraceHash Unknown...\nAs result function returns number of entries filled in BackTrace buffer, or zero in case of\nerror.\nSupported on system versions:\nNT 4.0,Win 2000,Win XP/2003\n\nDocumented by:\nTomasz Nowak\nRequirements:\n\nLibrary: ntdll.lib\n\nSee also:\nRtlGetCallersAddress\n"
      }
}